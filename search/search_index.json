{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"Changelog/","title":"Changelog","text":""},{"location":"Changelog/#java-crash-course","title":"Java Crash Course","text":""},{"location":"Code-of-conduct/","title":"Code of conduct","text":""},{"location":"How-to-Contribute/","title":"How to Contribute","text":""},{"location":"Tag-index/","title":"Tag index","text":""},{"location":"01-introduction/introduction-to-cp/","title":"Introduction to CP","text":"","tags":["introduction"]},{"location":"01-introduction/introduction-to-cp/#introduction-to-competitive-programming","title":"Introduction to Competitive Programming","text":"<p>Competitive Programming adalah olahraga mental yang memungkinkan kamu untuk menulis kode guna menyelesaikan suatu permasalahan dengan batasan yang diberikan. Tujuan dari materi ini adalah untuk membimbing setiap individu yang ingin unggul dalam bidang ini. Materi ini menyediakan silabus lengkap untuk Competitive Programming yang dirancang oleh para ahli industri guna meningkatkan persiapan para pembaca.</p>","tags":["introduction"]},{"location":"01-introduction/introduction-to-cp/#apa-itu-competitive-programming","title":"Apa itu Competitive Programming","text":"<p>Competitive programming adalah olahraga pikiran, di mana individu bersaing satu sama lain untuk menyelesaikan pertanyaan atau logika pemrograman dengan pendekatan yang efisien dalam batas waktu yang ditentukan. Tujuan utama dari competitive programming adalah menulis kode yang mampu menyelesaikan suatu masalah dalam waktu yang diberikan.</p>","tags":["introduction"]},{"location":"01-introduction/introduction-to-cp/#mengapa-harus-mengikuti-competitive-programming","title":"Mengapa Harus Mengikuti Competitive Programming","text":"<p>Competitive programming adalah cara terbaik untuk mengasah pemikiran analitis, logika, serta meningkatkan keterampilan coding. Banyak perusahaan teknologi besar seperti Google dan Facebook kini menjadikannya sebagai pertimbangan utama dalam proses rekrutmen. Bahkan, Facebook (Meta) mengadakan Meta Hacker Cup setiap tahun untuk mendorong para competitive programmer dari seluruh dunia bersaing dan mendapatkan kesempatan untuk direkrut oleh Meta.</p>","tags":["introduction"]},{"location":"01-introduction/introduction-to-cp/#berikut-adalah-beberapa-alasan","title":"Berikut adalah beberapa alasan","text":"<ul> <li>Ketangkasan Mental dan Berpikir Cepat: Dengan berlatih competitive programming, kamu akan terbiasa berpikir cepat dalam batas waktu tertentu, sehingga meningkatkan ketangkasan mental dan kemampuan berpikir secara efisien.</li> <li>Semangat Kompetitif: Competitive programming bisa menjadi aktivitas yang menyenangkan bagi mereka yang menikmati tantangan. Menyelesaikan soal sulit dalam batas waktu akan meningkatkan rasa percaya diri dan kepuasan pribadi.</li> <li>Prospek Karier: Competitive programming sangat penting dalam wawancara teknis untuk pekerjaan yang berhubungan dengan rekayasa perangkat lunak. Banyak perusahaan teknologi besar seperti Google, ServiceNow, Atlassian, dan lainnya menggunakan kompetisi competitive programming sebagai salah satu metode rekrutmen mereka.</li> <li>Peluang Belajar: Dalam competitive programming, terdapat berbagai jenis soal serta konsep aritmetika yang luas. Kamu juga akan diperkenalkan dengan berbagai struktur data dan algoritma yang membantu memahami kompleksitas suatu masalah dengan lebih baik.</li> <li>Pertumbuhan Pribadi sebagai Programmer: Competitive programming adalah salah satu cara terbaik untuk berkembang sebagai programmer. Kamu akan menguasai problem-solving karena harus menyelesaikan berbagai tantangan dalam batas waktu tertentu.</li> <li>Jaringan dan Komunitas: Berpartisipasi dalam berbagai kompetisi pemrograman memberikan kesempatan untuk menjadi bagian dari komunitas dengan orang-orang yang memiliki minat yang sama. Dalam komunitas ini, kamu bisa mendapatkan berbagai sumber daya penting serta bimbingan dari para ahli yang dapat membantumu mendapatkan referensi pekerjaan, informasi lowongan kerja, mentorship, dan banyak lagi.</li> </ul>","tags":["introduction"]},{"location":"01-introduction/introduction-to-cp/#competitive-programming-by-antti-laaksonen","title":"Competitive Programming by Antti Laaksonen","text":"Info <p>Ini adalah pengertian berbeda yang diambil dari  Competitive Programming Handbook by Antti Laaksonen.</p> <p>Competitive programming menggabungkan dua topik: (1) desain algoritma dan (2) implementasi algoritma.</p> <p>Desain algoritma terdiri dari pemecahan masalah dan pemikiran matematis. Keterampilan untuk menganalisis masalah dan menyelesaikannya dengan kreatif sangat diperlukan. Algoritma untuk menyelesaikan sebuah masalah harus benar dan efisien, dan inti dari masalah sering kali terletak pada menciptakan algoritma yang efisien.</p> <p>Pengetahuan teoretis tentang algoritma sangat penting bagi para competitive programmer. Biasanya, solusi untuk sebuah masalah adalah kombinasi dari teknik-teknik yang sudah dikenal dan wawasan baru. Teknik-teknik yang muncul dalam competitive programming juga membentuk dasar untuk penelitian ilmiah tentang algoritma.</p> <p>Implementasi algoritma membutuhkan keterampilan pemrograman yang baik. Dalam competitive programming, solusi dinilai dengan menguji algoritma yang diimplementasikan menggunakan serangkaian kasus uji. Jadi, tidak cukup hanya ide algoritma yang benar, implementasinya juga harus benar.</p> <p>Gaya penulisan kode yang baik dalam kontes adalah yang langsung dan ringkas. Program harus ditulis dengan cepat, karena waktu yang tersedia terbatas. Berbeda dengan rekayasa perangkat lunak tradisional, program-program ini singkat (biasanya tidak lebih dari beberapa ratus baris kode), dan tidak perlu dipelihara setelah kontes.</p>","tags":["introduction"]},{"location":"01-introduction/memilih-bahasa-pemrograman/","title":"Bahasa pemrograman","text":"","tags":["introduction"]},{"location":"01-introduction/memilih-bahasa-pemrograman/#bahasa-dalam-competitive-programming","title":"Bahasa dalam Competitive Programming","text":"<p>Dalam competitive programming, beberapa bahasa pemrograman lebih populer dibandingkan yang lain karena kecepatan eksekusi, fleksibilitas, dan dukungan pustaka bawaan. Berikut adalah tiga bahasa utama yang paling sering digunakan, urutan berdasarkan popularitas:</p>","tags":["introduction"]},{"location":"01-introduction/memilih-bahasa-pemrograman/#c","title":"C++","text":"<ol> <li> <p>Kecepatan Eksekusi Tinggi</p> <ul> <li>C++ adalah bahasa yang dikompilasi (compiled), bukan interpreted seperti Python, sehingga eksekusi program jauh lebih cepat.</li> <li>Dalam kompetisi, sering ada batasan waktu yang ketat, dan C++ memungkinkan peserta menangani batasan waktu lebih baik daripada bahasa lain.</li> </ul> </li> <li> <p>STL (Standard Template Library):</p> <ul> <li>STL menyediakan struktur data dan algoritma bawaan yang sangat cepat dan optimal.</li> <li>Contohnya:<ul> <li><code>vector</code> \u2192 Array dinamis yang fleksibel.</li> <li><code>set</code> dan <code>map</code> \u2192 Struktur data berbasis tree untuk pencarian cepat.</li> <li><code>priority_queue</code> \u2192 Implementasi heap yang efisien.</li> <li><code>unordered_map</code> \u2192 Hash table dengan pencarian \\(O(1)\\).</li> <li><code>sort()</code> \u2192 Algoritma sorting yang sangat cepat dengan kompleksitas \\(O(n \\log n)\\).</li> </ul> </li> </ul> </li> <li> <p>Manipulasi Memori yang Efisien:</p> <ul> <li>C++ memungkinkan alokasi memori manual dengan pointer dan <code>malloc()</code>, yang bisa digunakan untuk optimasi ekstrem.</li> <li>Tidak ada garbage collection seperti di Java atau Python, sehingga lebih cepat.</li> </ul> </li> <li> <p>Kompatibilitas dengan Algoritma CP:</p> <ul> <li>Banyak algoritma yang diajarkan di CP langsung menggunakan sintaks C++, sehingga peserta lebih mudah menerapkannya.</li> </ul> </li> </ol> <p>Namun, seperti banyak hal pada umumnya, tidak ada kelebihan tanpa kekurangan. Berikut kekurangan dari C++:</p> <ol> <li> <p>Debugging lebih sulit     Tidak memiliki error handling bawaan seperti Python.  </p> </li> <li> <p>Sintaks kompleks     Membutuhkan pemahaman mendalam tentang pointer, reference, dan memory management.</p> </li> </ol> <p>Tip</p> <p>C++ adalah bahasa yang paling populer dalam CP karena kecepatan dan STL yang sangat kuat.</p>","tags":["introduction"]},{"location":"01-introduction/memilih-bahasa-pemrograman/#python","title":"Python","text":"<ol> <li> <p>Sintaks yang lebih mudah dan ringkas</p> <ul> <li>Peserta dapat menulis kode yang lebih pendek dan lebih mudah dibaca dibandingkan C++.</li> <li> <p>Contoh sorting dalam Python hanya perlu satu baris:</p> <pre><code>arr.sort()\n</code></pre> <p>Sementara di C++:</p> <pre><code>sort(arr.begin(), arr.end());\n</code></pre> </li> </ul> </li> <li> <p>Dukungan Pustaka yang Kuat</p> <ul> <li>Python memiliki pustaka seperti <code>collections.Counter</code>, <code>heapq</code> (priority queue), dan <code>itertools</code> yang bisa membantu menyelesaikan masalah CP dengan lebih sedikit kode.</li> </ul> </li> <li> <p>Tipe Data Fleksibel</p> <ul> <li>Integer bisa otomatis menjadi besar (Big Integer), sementara di C++ kita harus menggunakan <code>long long</code>.</li> <li>List bisa menampung berbagai tipe data sekaligus.</li> </ul> </li> </ol> <p>Namun, seperti banyak hal pada umumnya, tidak ada kelebihan tanpa kekurangan. Berikut kekurangan dari Python:</p> <ol> <li> <p>Eksekusi Lebih Lambat (10x lebih lambat dari C++)</p> <ul> <li>Karena Python adalah bahasa interpreted, tidak secepat C++ dalam eksekusi.</li> <li>Untuk soal yang membutuhkan pengolahan data dalam jumlah besar (misal: 10\u2076 operasi), Python bisa TLE (Time Limit Exceeded).</li> </ul> </li> <li> <p>Tidak Ada Tipe Data Statis</p> </li> <li>Python tidak memiliki deklarasi tipe data seperti <code>int</code>, <code>long long</code>, atau <code>double</code>, sehingga bisa terjadi overhead dalam eksekusi.</li> </ol> <p>Tip</p> <p>Python cocok untuk debugging dan pemula, tapi kurang optimal untuk soal-soal dengan batasan waktu ketat.</p>","tags":["introduction"]},{"location":"01-introduction/memilih-bahasa-pemrograman/#java","title":"Java","text":"<ol> <li>Kecepatan Eksekusi di Tengah-tengah<ul> <li>Java lebih lambat dari C++, tetapi lebih cepat dari Python.</li> <li>Java dikompilasi menjadi bytecode yang dieksekusi oleh JVM (Java Virtual Machine), membuatnya cukup cepat.</li> </ul> </li> <li>Garbage Collection Otomatis<ul> <li>Java secara otomatis mengelola memori, mengurangi kemungkinan kesalahan pointer seperti di C++.</li> </ul> </li> <li> <p>Dukungan Struktur Data yang Kuat</p> <ul> <li><code>ArrayList</code> \u2192 Alternatif <code>vector</code> di C++.</li> <li><code>TreeSet</code>, <code>HashSet</code> \u2192 Untuk pencarian cepat.</li> <li><code>PriorityQueue</code> \u2192 Untuk heap seperti <code>priority_queue</code> di C++.</li> </ul> </li> </ol> <p>Namun, seperti banyak hal pada umumnya, tidak ada kelebihan tanpa kekurangan. Berikut kekurangan dari Java:</p> <ol> <li> <p>Sintaks Lebih Panjang</p> <ul> <li>Menulis kode lebih panjang dibandingkan C++ dan Python.</li> <li> <p>Contoh deklarasi input di Java:</p> <pre><code>Scanner sc = new Scanner(System.in);\nint n = sc.nextInt();\n</code></pre> <p>Sementara di C++ cukup:</p> <pre><code>int n;\ncin &gt;&gt; n;\n</code></pre> </li> </ul> </li> <li> <p>Startup Time Lebih Lambat</p> <ul> <li>JVM membutuhkan waktu tambahan untuk startup, membuatnya lebih lambat dibandingkan C++.</li> </ul> </li> </ol> <p>Tip</p> <p>Kesimpulan \u2192 Java cukup kuat untuk CP, tetapi sintaksnya lebih panjang dibandingkan C++.</p>","tags":["introduction"]},{"location":"01-introduction/memilih-bahasa-pemrograman/#materi-tambahan","title":"Materi tambahan","text":"Info <p>Materi dari Competitive Programming Handbook by Antti Laaksonen</p> <p>Saat ini, bahasa pemrograman yang paling populer digunakan dalam kontes adalah C++, Python, dan Java. Misalnya, dalam Google Code Jam 2017, di antara 3.000 peserta terbaik, 79% menggunakan C++, 16% menggunakan Python, dan 8% menggunakan Java. Beberapa peserta juga menggunakan beberapa bahasa.</p> <p>Banyak orang berpendapat bahwa C++ adalah pilihan terbaik untuk seorang competitive programmer, dan C++ hampir selalu tersedia di sistem kontes. Keuntungan menggunakan C++ adalah bahwa ini adalah bahasa yang sangat efisien dan pustaka standarnya mengandung banyak struktur data dan algoritma.</p> <p>Di sisi lain, ada baiknya menguasai beberapa bahasa pemrograman dan memahami kekuatannya. Misalnya, jika angka besar dibutuhkan dalam masalah, Python bisa menjadi pilihan yang baik, karena memiliki operasi built-in untuk perhitungan dengan angka besar. Namun, sebagian besar masalah dalam kontes pemrograman disusun sedemikian rupa sehingga penggunaan bahasa pemrograman tertentu tidak memberikan keuntungan yang tidak adil.</p> <p>Semua contoh program dalam buku ini ditulis dalam C++, dan struktur data serta algoritma dari pustaka standar sering digunakan. Program-program ini mengikuti standar C++11, yang dapat digunakan dalam sebagian besar kontes saat ini. Jika kamu belum bisa memrogram menggunakan C++, sekarang adalah waktu yang tepat untuk mulai belajar.</p>","tags":["introduction"]},{"location":"01-introduction/template-code/","title":"Template code","text":"","tags":["introduction"]},{"location":"01-introduction/template-code/#template-code-untuk-competitive-programming","title":"Template code untuk Competitive Programming","text":"<p>Dalam competitive programming, terdapat banyak cara yang bisa dilakukan untuk memaksimalkan kinerja kode program. Entah itu memudahkan dan mempercepat penulisan kode program, mempercepat eksekusi program, dan efisiensi lainya. Hal ini biasanya sudah tersusun sedemikian rupa dengan template code tertentu yang biasa digunakan dalam CP. </p> <p>Berikut diantaranya:</p>","tags":["introduction"]},{"location":"01-introduction/template-code/#basic-template-kode","title":"Basic template kode","text":"<p>Template kode C++:</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){ \n    // kode program\n\n    return 0;\n}\n</code></pre> <p>Penggunaan <code>using namespace std</code> mendeklarasikan bahwa kelas dan fungsi dari pustaka standar dapat digunakan langsung dalam kode. Tanpa baris ini, kita harus menulis, misalnya, <code>std::cout</code>, tetapi sekarang cukup menulis <code>cout</code>.</p> <p><code>#include &lt;bits/stdc++.h&gt;</code> adalah sebuah header file \"all-in-one\" yang tersedia di banyak compiler berbasis GCC (GNU Compiler Collection). Header ini meng-include hampir semua pustaka standar C++ dalam satu perintah, yang membuatnya populer di kalangan programmer kompetitif untuk menghemat waktu saat menuliskan kode (hanya untuk CP, tidak dianjurkan di produksi).</p>","tags":["introduction"]},{"location":"01-introduction/template-code/#apa-yang-ada-di-dalam-bitsstdch","title":"Apa yang Ada di Dalam <code>bits/stdc++.h</code>","text":"<p>Ketika Anda menuliskan <code>#include &lt;bits/stdc++.h&gt;</code>, ini akan menyertakan hampir seluruh pustaka C++ standar, termasuk:</p> <ul> <li><code>&lt;iostream&gt;</code>: Untuk input dan output standar.</li> <li><code>&lt;vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;queue&gt;</code>, <code>&lt;stack&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;unordered_map&gt;</code>, <code>&lt;unordered_set&gt;</code>: Struktur data STL (Standard Template Library).</li> <li><code>&lt;algorithm&gt;</code>: Fungsi-fungsi algoritmik seperti <code>sort</code>, <code>find</code>, <code>reverse</code>, dll.</li> <li><code>&lt;cmath&gt;</code>, <code>&lt;cstdio&gt;</code>, <code>&lt;cstdlib&gt;</code>, <code>&lt;cstring&gt;</code>: Fungsi-fungsi matematika, manipulasi string C, dan fungsi I/O.</li> <li><code>&lt;string&gt;</code>, <code>&lt;sstream&gt;</code>: Pustaka untuk memanipulasi string.</li> <li><code>&lt;functional&gt;</code>: Mendukung pemrograman fungsional seperti <code>std::function</code>, <code>std::bind</code>, dll.</li> <li><code>&lt;utility&gt;</code>: Struktur data <code>pair</code>, <code>std::swap</code>, dll.</li> </ul>","tags":["introduction"]},{"location":"01-introduction/template-code/#keuntungan-menggunakan-include-bitsstdch","title":"Keuntungan Menggunakan <code>#include &lt;bits/stdc++.h&gt;</code>","text":"<ol> <li> <p>Menghemat Waktu: Dengan satu baris <code>#include &lt;bits/stdc++.h&gt;</code>, programmer mendapatkan akses ke hampir semua pustaka C++ standar yang mungkin diperlukan. Ini sangat berguna dalam kompetisi pemrograman, di mana waktu sangat penting.</p> </li> <li> <p>Kode Lebih Ringkas: Karena mencakup semua header, kode menjadi lebih singkat dan mudah dibaca tanpa daftar panjang header yang perlu di-include satu per satu.</p> </li> </ol>","tags":["introduction"]},{"location":"01-introduction/template-code/#kekurangan-menggunakan-include-bitsstdch","title":"Kekurangan Menggunakan <code>#include &lt;bits/stdc++.h&gt;</code>","text":"<ol> <li> <p>Membuat Kompilasi Lebih Lambat: Menggunakan <code>#include &lt;bits/stdc++.h&gt;</code> meng-include semua pustaka standar, sehingga waktu kompilasi dapat menjadi lebih lambat karena harus memuat lebih banyak pustaka daripada yang sebenarnya diperlukan.</p> </li> <li> <p>Tidak Portabel: Header ini tidak termasuk dalam standar C++ dan hanya tersedia di GCC. Jika Anda mencoba menjalankan kode ini di compiler lain (seperti MSVC atau Clang tanpa kompatibilitas GCC), kompilasi kemungkinan besar akan gagal.</p> </li> <li> <p>Pemakaian Memori yang Lebih Tinggi: Karena banyak pustaka yang di-include, program mungkin akan menggunakan lebih banyak memori.</p> </li> </ol> <p>Tip</p> <p><code>#include &lt;bits/stdc++.h&gt;</code> adalah header praktis yang digunakan dalam pemrograman kompetitif untuk menghemat waktu. Namun, untuk proyek yang lebih besar atau produksi, disarankan untuk meng-include pustaka yang benar-benar diperlukan saja agar kompilasi lebih cepat, memori lebih efisien, dan kode lebih portabel.</p>","tags":["introduction"]},{"location":"01-introduction/template-code/#advanced-template-code","title":"Advanced template code","text":"<p>Untuk bisa memahami dengan baik Advanced template code ini, pelajari terlebih dahulu materi Introduction to CP hingga selesai! </p> <p>Template kode dalam competitive programming biasanya dirancang agar ringkas, cepat, dan mempermudah pengambilan input serta pemrosesan data. Berikut adalah template umum yang sering digunakan:</p>","tags":["introduction"]},{"location":"01-introduction/template-code/#template-dasar-competitive-programming","title":"Template Dasar Competitive Programming","text":"<pre><code>#include &lt;bits/stdc++.h&gt; \nusing namespace std;\n\n#define fastio() ios_base::sync_with_stdio(0); cin.tie(0);\n#define ll long long\n#define vi vector&lt;int&gt;\n#define vll vector&lt;ll&gt;\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;ll, ll&gt;\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\n#define rep(i, a, b) for (int i = a; i &lt; b; i++)\n#define rev(i, a, b) for (int i = a; i &gt;= b; i--)\n\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX;\n\nvoid solve() {\n    // kode program\n}\n\nint main() {\n\n    fastio();\n    // kode program\n\n    return 0;\n}\n</code></pre> <p>Contoh Penggunaan:</p> <pre><code>#include &lt;bits/stdc++.h&gt; \nusing namespace std;\n\n#define fastio() ios_base::sync_with_stdio(0); cin.tie(0);\n#define ll long long\n#define vi vector&lt;int&gt;\n#define vll vector&lt;ll&gt;\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;ll, ll&gt;\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\n#define rep(i, a, b) for (int i = a; i &lt; b; i++)\n#define rev(i, a, b) for (int i = a; i &gt;= b; i--)\n\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX;\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n    vi arr(n);\n    for (int &amp;x : arr) cin &gt;&gt; x;\n\n    sort(all(arr)); // Contoh operasi\n    cout &lt;&lt; arr[n / 2] &lt;&lt; \"\\n\"; // Contoh output\n}\n\nint main() {\n    fastio();\n    int t = 1;\n    cin &gt;&gt; t; \n    while (t--) solve();\n    return 0;\n}\n</code></pre>","tags":["introduction"]},{"location":"01-introduction/template-code/#penjelasan-dan-fitur","title":"Penjelasan dan Fitur:","text":"<ol> <li>Header <code>&lt;bits/stdc++.h&gt;</code> \u2192 Mengimpor semua pustaka STL sekaligus.</li> <li><code>fastio()</code> \u2192 Mempercepat input/output untuk menghindari TLE (Time Limit Exceeded).</li> <li>Alias &amp; Macro (<code>#define</code>)<ul> <li><code>ll</code> \u2192 <code>long long</code></li> <li><code>vi</code> \u2192 <code>vector&lt;int&gt;</code></li> <li><code>vll</code> \u2192 <code>vector&lt;long long&gt;</code></li> <li><code>pii</code> \u2192 <code>pair&lt;int, int&gt;</code></li> <li><code>pb</code> \u2192 <code>push_back()</code></li> <li><code>all(x)</code> \u2192 <code>x.begin(), x.end()</code> (memudahkan penggunaan <code>sort()</code> dan lainnya)</li> <li><code>sz(x)</code> \u2192 <code>x.size()</code></li> </ul> </li> <li>Looping Cepat<ul> <li><code>rep(i, a, b)</code> \u2192 Loop dari <code>a</code> sampai <code>b-1</code></li> <li><code>rev(i, a, b)</code> \u2192 Loop mundur dari <code>a</code> sampai <code>b</code></li> </ul> </li> <li><code>solve()</code> function \u2192 Struktur umum dalam CP untuk menangani satu kasus uji.</li> <li>Modular Arithmetic \u2192 <code>const int MOD = 1e9 + 7;</code> sering digunakan dalam perhitungan besar.</li> </ol>","tags":["introduction"]},{"location":"01-introduction/template-code/#variasi-template-untuk-cp","title":"Variasi Template untuk CP","text":"<ul> <li> <p>Jika Butuh Graph / BFS / DFS       </p><pre><code>vector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; visited;\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor);\n        }\n    }\n}\n</code></pre><p></p> </li> <li> <p>Jika Butuh Binary Search      </p><pre><code>int binary_search(vector&lt;int&gt;&amp; arr, int target) {\n    int l = 0, r = sz(arr) - 1;\n    while (l &lt;= r) {\n        int mid = (l + r) / 2;\n        if (arr[mid] == target) return mid;\n        else if (arr[mid] &lt; target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return -1; // Tidak ditemukan\n}\n</code></pre><p></p> </li> <li> <p>Jika Butuh Modular Exponentiation      </p><pre><code>ll mod_exp(ll base, ll exp, ll mod) {\n    ll result = 1;\n    while (exp &gt; 0) {\n        if (exp % 2 == 1) result = (result * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n</code></pre><p></p> </li> </ul>","tags":["introduction"]},{"location":"01-introduction/template-code/#real-man-template-code","title":"Real man Template code","text":"<p>Haha, diluar sana juga ada banyak praktisi CP yang berbagi template codenya, jadi kita juga bisa mengambil template code tersebut, dan merubahnya atau menggunakanya sesuai selera kita. Berikut diantaranya:</p> <p>Jangan terlalu kaku!</p> <p>Template code dari orang lain ini mungkin terlalu banyak jika benar-benar digunakan. Tidak semua template code ini benar-benar dibutuhkan. Jadi, gunakan sebagai bahan referensi, dan tulis template code yang sesuai dengan kondisi dan kebutuhanmu saat ini!</p>","tags":["introduction"]},{"location":"01-introduction/template-code/#neilblaze","title":"Neilblaze","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n/* clang-format off */\n\n/* TYPES  */\n#define ll long long\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;long long, long long&gt;\n#define vi vector&lt;int&gt;\n#define vll vector&lt;long long&gt;\n#define mii map&lt;int, int&gt;\n#define si set&lt;int&gt;\n#define sc set&lt;char&gt;\n\n/* FUNCTIONS */\n#define f(i,s,e) for(long long int i=s;i&lt;e;i++)\n#define cf(i,s,e) for(long long int i=s;i&lt;=e;i++)\n#define rf(i,e,s) for(long long int i=e-1;i&gt;=s;i--)\n#define pb push_back\n#define eb emplace_back\n\n/* PRINTS */\ntemplate &lt;class T&gt;\nvoid print_v(vector&lt;T&gt; &amp;v) { cout &lt;&lt; \"{\"; for (auto x : v) cout &lt;&lt; x &lt;&lt; \",\"; cout &lt;&lt; \"\\b}\"; }\n\n/* UTILS */\n#define MOD 1000000007\n#define PI 3.1415926535897932384626433832795\n#define read(type) readInt&lt;type&gt;()\nll min(ll a,int b) { if (a&lt;b) return a; return b; }\nll min(int a,ll b) { if (a&lt;b) return a; return b; }\nll max(ll a,int b) { if (a&gt;b) return a; return b; }\nll max(int a,ll b) { if (a&gt;b) return a; return b; }\nll gcd(ll a,ll b) { if (b==0) return a; return gcd(b, a%b); }\nll lcm(ll a,ll b) { return a/gcd(a,b)*b; }\nstring to_upper(string a) { for (int i=0;i&lt;(int)a.size();++i) if (a[i]&gt;='a' &amp;&amp; a[i]&lt;='z') a[i]-='a'-'A'; return a; }\nstring to_lower(string a) { for (int i=0;i&lt;(int)a.size();++i) if (a[i]&gt;='A' &amp;&amp; a[i]&lt;='Z') a[i]+='a'-'A'; return a; }\nbool prime(ll a) { if (a==1) return 0; for (int i=2;i&lt;=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }\nvoid yes() { cout&lt;&lt;\"YES\\n\"; }\nvoid no() { cout&lt;&lt;\"NO\\n\"; }\n\n/*  All Required define Pre-Processors and typedef Constants */\ntypedef long int int32;\ntypedef unsigned long int uint32;\ntypedef long long int int64;\ntypedef unsigned long long int  uint64;\n\n\n/* clang-format on */\n\n/* Main()  function */\nint main()\n{\n\n    #ifndef ONLINE_JUDGE\n    freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    #endif\n\n    int tc;\n    tc = read(int);\n\n    while(tc--){\n        write(tc);\n    }\n    return 0;\n}\n/* Main() Ends Here */\n</code></pre> <p>Dengan ekstras:</p> <pre><code>#define f first\n#define s second\n#define endl '\\n'\n#define sp &lt;&lt;\" \"&lt;&lt;\n#define pb push_back\n#define MOD 1000000007\n#define fora(a) for(auto u:a)\n#define gcd(a,b) __gcd(a,b)\n#define lcm(a,b) (a*(b/gcd(a,b)))\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define test int tc; cin&gt;&gt;tc; while(tc--)\n#define forn(i,n) for(auto i=0; i&lt;n; i++)\n#define printv(a) {for(auto u:a) cout&lt;&lt;u&lt;&lt;\" \"; cout&lt;&lt;endl;}\n#define printm(a) {for(auto u:a) cout&lt;&lt;u.f sp u.s&lt;&lt;endl;}\n#define op() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define fori(a,b,c) {for(a = c.begin(); a!=b; a++) cout&lt;&lt; *a&lt;&lt; \" \"; cout&lt;&lt;endl;}\n#define fraction(a) cout.unsetf(ios::floatfield); cout.precision(a); cout.setf(ios::fixed,ios::floatfield);\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector&lt;ll&gt; vl;\ntypedef vector&lt;int&gt; vi;\ntypedef vector&lt;char&gt; vc;\ntypedef vector&lt;string&gt; vs;\ntypedef vector&lt;int&gt;::iterator vit;\ntypedef set&lt;int&gt; si;\ntypedef map&lt;int, int&gt; mii;\nconst double eps = 1e-9;\n</code></pre>","tags":["introduction"]},{"location":"01-introduction/template-code/#ncduy0303","title":"ncduy0303","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntemplate&lt;typename A, typename B&gt; ostream&amp; operator&lt;&lt;(ostream &amp;os, const pair&lt;A, B&gt; &amp;p) { return os &lt;&lt; '(' &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; ')'; }\ntemplate&lt;typename T_container, typename T = typename enable_if&lt;!is_same&lt;T_container, string&gt;::value, typename T_container::value_type&gt;::type&gt; ostream&amp; operator&lt;&lt;(ostream &amp;os, const T_container &amp;v) { os &lt;&lt; '{'; string sep; for (const T &amp;x : v) os &lt;&lt; sep &lt;&lt; x, sep = \", \"; return os &lt;&lt; '}'; }\nvoid dbg_out() { cerr &lt;&lt; endl; }\ntemplate&lt;typename Head, typename... Tail&gt; void dbg_out(Head H, Tail... T) { cerr &lt;&lt; ' ' &lt;&lt; H; dbg_out(T...); }\n#ifdef LOCAL\n#define dbg(...) cerr &lt;&lt; \"(\" &lt;&lt; #__VA_ARGS__ &lt;&lt; \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n#define ar array\n#define ll long long\n#define ld long double\n#define sza(x) ((int)x.size())\n#define all(a) (a).begin(), (a).end()\n\nconst int MAX_N = 1e5 + 5;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9;\nconst ld EPS = 1e-9;\n\n\n\nvoid solve() {\n\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    int tc = 1;\n    // cin &gt;&gt; tc;\n    for (int t = 1; t &lt;= tc; t++) {\n        // cout &lt;&lt; \"Case #\" &lt;&lt; t &lt;&lt; \": \";\n        solve();\n    }\n}\n</code></pre>","tags":["introduction"]},{"location":"01-introduction/template-code/#7oskaaa","title":"7oSkaaa","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n#define fixed(n) fixed &lt;&lt; setprecision(n)\n#define ceil(n, m) (((n) + (m) - 1) / (m))\n#define add_mod(a, b, m) (((a % m) + (b % m)) % m)\n#define sub_mod(a, b, m) (((a % m) - (b % m) + m) % m)\n#define mul_mod(a, b, m) (((a % m) * (b % m)) % m)\n#define all(vec) vec.begin(), vec.end()\n#define rall(vec) vec.rbegin(), vec.rend()\n#define sz(x) int(x.size())\n#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; (x) &lt;&lt; \"\\n\";\n#define fi first\n#define se second\n#define ll long long\n#define ull unsigned long long\n#define EPS 1e-9\nconstexpr int INF = 1 &lt;&lt; 30, Mod = 1e9 + 7;\nconstexpr ll LINF = 1LL &lt;&lt; 62;\n#define PI acos(-1)\ntemplate &lt; typename T = int &gt; using Pair = pair &lt; T, T &gt;;\nvector &lt; string &gt; RET = {\"NO\", \"YES\"};\n\ntemplate &lt; typename T = int &gt; istream&amp; operator &gt;&gt; (istream &amp;in, vector &lt; T &gt; &amp;v) {\n    for (auto &amp;x : v) in &gt;&gt; x;\n    return in;\n}\n\ntemplate &lt; typename T = int &gt; ostream&amp; operator &lt;&lt; (ostream &amp;out, const vector &lt; T &gt; &amp;v) { \n    for (const T &amp;x : v) out &lt;&lt; x &lt;&lt; ' '; \n    return out;\n}\n\nvoid Solve(){\n\n}\n\nint main(){\n    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n    int test_cases = 1;\n    // cin &gt;&gt; test_cases;\n    for(int tc = 1; tc &lt;= test_cases; tc++){\n        // cout &lt;&lt; \"Case #\" &lt;&lt; tc &lt;&lt; \": \";\n        Solve();\n    }\n    return 0;\n}\n</code></pre>","tags":["introduction"]},{"location":"codeforces/1200/1808B-playing-in-a-casino/","title":"1808B - Playing in a Casino","text":"","tags":["math","sortings"]},{"location":"codeforces/1200/1808B-playing-in-a-casino/#1808b-playing-in-a-casino","title":"1808B - Playing in a Casino","text":"<p>Sumber: 1808B - Playing in a Casino</p> <p>Didalam sebuah kasino, terdapat \\(n\\) pemain yang bermain dengan \\(n\\) deck kartu. Setiap kartu, memiliki tepat \\(m\\) angka yang tertulis didalamnya.</p> <p>Permain dilakukan dengan cara berpasangan dengan semua pemain yang ada. Misal ada \\(4\\) pemain, maka akan dilakukan \\(6\\) permainan, karena pemain pertama bermain dengan pemain kedua, ketiga, dan keempat. Pemain kedua bermain dengan pemain ketiga dan keempat. Dan pemain ketiga bermain dengan pemain keemapat. Total ada \\(6\\) permainan.</p> <p>Setiap game, menentukan pemenang dengan cara yang cukup kompleks. Pemenang dari setiap permainan berpasangan akan mendapatkan chip, semisal pemain \\(a\\) memiliki kartu dengan angka \\(a_1, a_2, \\cdots a_m\\), dan pemain kedua memiliki kartu dengan angka \\(b_1, b_2, \\cdots, b_m\\), maka pemanang akan mendapatkan chip sebanyak \\(|a_1 - b_1| + ||a_2 - b_2| + \\cdots + |a_m - b_m|\\).</p> <p>Untuk menentukan kebutuhan chip yang diperlukan, hitung total chip yang mungkin untuk didapatkan seorang pemenang dalam setiap permainan. Karena mungkin untuk memiliki banyak pemain dan kartu, tugasmu adalah membuat program yang bisa menghitung kebutuhan deck maksimal ini</p>","tags":["math","sortings"]},{"location":"codeforces/1200/1808B-playing-in-a-casino/#analisisa-awal","title":"Analisisa Awal","text":"<p>inputan yang diberikan adalah \\(n\\) yang menyatakan banyaknya player dan kartu, dan \\(m\\) yang menyatakan banyaknya angka pada setiap kartu.</p> <p>Batasan yang diberikan oleh soal ini adalah \\(1 \\leq n \\cdot m \\leq 3 \\cdot 10^5\\). Dan setiap angka pada kartu memiliki batasan berupa \\(1 \\leq C_{i,j} \\leq 10^6\\), yang mendeskripsikan besaran kartu ke-\\(i\\).</p> <p>Dengan menggunakan pendekatan biasa, sangat mungkin untuk menyelesaikan masalah ini dengan menggunakan nested loops tiga lapis, namun kompleksitas \\(O(n^3)\\) jelas akan melebihi time limit, karena itu adalah pendekatan naif.</p> <p>Kode dibawah ini bisa menyelesaikankan beberapa testcase, namun tidak mungkin untuk menangani inputan berukuran besar, sehingga berakhir time limit exceed:</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n    ll n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;ll&gt;&gt; v (n, vector&lt;ll&gt;(m));\n    for (auto&amp; r : v) {\n        for (auto&amp; x : r) {\n            cin &gt;&gt; x;\n        }\n    }\n\n    ll sum = 0; \n    for (int i=0; i &lt; n-1; i++) { // (1)\n        for (int j=i+1; j&lt;n; j++) {\n            for (int k=0; k&lt;m; k++) {\n                sum += abs(v[i][k] - v[j][k]);\n            }\n        }\n    }\n    cout &lt;&lt; sum &lt;&lt; \"\\n\";\n}\n\nauto main() -&gt; int {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while (t--) solve();\n    return 0;\n}\n</code></pre> <ol> <li>Nested loops ini menggunakan kompleksitas \\(O(n^3)\\), mengakibatkan time limit exceed</li> </ol>","tags":["math","sortings"]},{"location":"codeforces/1200/1808B-playing-in-a-casino/#jawaban-dan-editorial","title":"Jawaban dan Editorial","text":"","tags":["math","sortings"]},{"location":"codeforces/1200/1808B-playing-in-a-casino/#analisis-editorial","title":"Analisis Editorial","text":"<p>Anda mungkin memperhatikan bahwa masalahnya dapat diselesaikan secara independen untuk setiap kolom dari matriks input. Jawabannya kemudian adalah jumlah \\(\\sum_{i=1}^{n}\\sum_{j=i+1}^{n}|a_i - a_j|\\), di mana \\(a\\) adalah larik yang mewakili satu kolom.</p> <p>Mari kita coba hitung jumlah ini untuk setiap kolom.</p> <ol> <li>Mari kita urutkan semua elemen dari kolom saat ini.</li> <li>Mari kita hitung jawabannya untuk beberapa elemen di daftar yang sudah diurutkan.</li> <li>Jawabannya untuk elemen tersebut adalah \\(a_i \\cdot i - \\text{sum}\\), di mana \\(\\text{sum}\\) adalah jumlah pada prefix (jumlah elemen-elemen sebelumnya).</li> </ol> <p>Mengapa demikian? Karena kita menganggap bahwa bilangan ini (\\(a_i\\)) lebih besar daripada yang lain (yaitu elemen-elemen di prefix). Dengan demikian, modulus akan terurai menjadi \\(|a_i - a_j| = a_i - a_j\\), dan ini sudah mudah dihitung.</p>","tags":["math","sortings"]},{"location":"codeforces/1200/1808B-playing-in-a-casino/#analisis-pribadi","title":"Analisis Pribadi","text":"","tags":["math","sortings"]},{"location":"codeforces/1200/1808B-playing-in-a-casino/#analisis-jawaban-lain","title":"Analisis Jawaban Lain","text":"","tags":["math","sortings"]}]}