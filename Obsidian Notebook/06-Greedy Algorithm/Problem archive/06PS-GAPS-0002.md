---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0002
judul_problem: Jumlah Minimum Gerakan untuk Menempatkan Semua Orang di Kursi
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ¤ O(n log n)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-15T00:16:00
pendekatan: greedy algorithm
tags:
  - greedy
---
Link problem: [Minimum Number of Moves to Seat Everyone - LeetCode](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/description/?envType=problem-list-v2&envId=greedy)

#greedy 

---
# Jumlah Minimum Gerakan untuk Menempatkan Semua Orang di Kursi
Time limit: -
Memory limit: -

Terdapat `n` kursi yang tersedia dan `n` siswa yang berdiri di dalam sebuah ruangan. Kamu diberikan array **`seats`** yang memiliki panjang `n`, di mana `seats[i]` adalah posisi dari kursi ke-`i`. Kamu juga diberikan array **`students`** yang memiliki panjang `n`, di mana `students[j]` adalah posisi dari siswa ke-`j`.

Kamu dapat melakukan gerakan berikut ini sebanyak mungkin:

- Menambah atau mengurangi posisi siswa ke-`i` sebanyak 1 (misalnya, memindahkan siswa ke posisi `x` menjadi `x + 1` atau `x - 1`).
    

Kembalikan **jumlah minimum gerakan yang diperlukan** untuk memindahkan setiap siswa ke kursi, sehingga **tidak ada dua siswa yang duduk di kursi yang sama**.

Perhatikan bahwa mungkin ada beberapa kursi atau siswa yang berada di posisi yang sama pada awalnya.

---

### Contoh 1:

**Input:**

```
seats = [3, 1, 5]
students = [2, 7, 4]
```

**Output:**

```
4
```

**Penjelasan:** Siswa dipindahkan sebagai berikut:

- Siswa pertama dipindahkan dari posisi `2` ke posisi `1` dengan 1 gerakan.
    
- Siswa kedua dipindahkan dari posisi `7` ke posisi `5` dengan 2 gerakan.
    
- Siswa ketiga dipindahkan dari posisi `4` ke posisi `3` dengan 1 gerakan. Total gerakan yang digunakan: `1 + 2 + 1 = 4` gerakan.
    

---

### Contoh 2:

**Input:**

```
seats = [4, 1, 5, 9]
students = [1, 3, 2, 6]
```

**Output:**

```
7
```

**Penjelasan:** Siswa dipindahkan sebagai berikut:

- Siswa pertama tidak dipindahkan.
    
- Siswa kedua dipindahkan dari posisi `3` ke posisi `4` dengan 1 gerakan.
    
- Siswa ketiga dipindahkan dari posisi `2` ke posisi `5` dengan 3 gerakan.
    
- Siswa keempat dipindahkan dari posisi `6` ke posisi `9` dengan 3 gerakan. Total gerakan yang digunakan: `0 + 1 + 3 + 3 = 7` gerakan.
    

---

### Contoh 3:

**Input:**

```
seats = [2, 2, 6, 6]
students = [1, 3, 2, 6]
```

**Output:**

```
4
```

**Penjelasan:** Perhatikan bahwa ada dua kursi di posisi `2` dan dua kursi di posisi `6`.  
Siswa dipindahkan sebagai berikut:

- Siswa pertama dipindahkan dari posisi `1` ke posisi `2` dengan 1 gerakan.
    
- Siswa kedua dipindahkan dari posisi `3` ke posisi `6` dengan 3 gerakan.
    
- Siswa ketiga tidak dipindahkan.
    
- Siswa keempat tidak dipindahkan. Total gerakan yang digunakan: `1 + 3 + 0 + 0 = 4` gerakan.
    

---

### Batasan:

- `n == seats.length == students.length`
    
- `1 <= n <= 100`
    
- `1 <= seats[i], students[j] <= 100`
    

# Jawaban
Jawaban ini sudah cukup efisien:

```cpp
class Solution {
public:
    int minMovesToSeat(vector<int>& seats, vector<int>& students) {
        sort(seats.begin(), seats.end());
        sort(students.begin(), students.end());

        int totalMoves = 0;
        for (int i = 0; i < seats.size(); i++) {
            totalMoves += abs(seats[i] - students[i]);
        }

        return totalMoves;
    }
};
```

Time complexity: $O(n \;log\;n)$
Memory complexity: $O(1)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 

## ğŸ¯ Tujuan:

Pasangkan setiap siswa ke kursi sedekat mungkin, **agar total langkah minimum**.

## ğŸ’¡ Ide Greedy:

Bayangkan kita punya:

- Kursi = `[3, 1, 5]`
    
- Siswa = `[2, 7, 4]`
    

Kalau kita pasangkan secara acak, mungkin langkahnya banyak.  
Tapi kalau kita **urutkan** keduanya dulu:

```
seats =   [1, 3, 5]
students = [2, 4, 7]
```

Sekarang kita tinggal **pasangkan satu per satu secara berurutan**:

- Pasangkan `1` dengan `2` â†’ `|1 - 2| = 1`
    
- Pasangkan `3` dengan `4` â†’ `|3 - 4| = 1`
    
- Pasangkan `5` dengan `7` â†’ `|5 - 7| = 2`
    

Total langkah = `1 + 1 + 2 = 4 âœ…`

â¡ï¸ **Inti greedy-nya**: urutkan dua array, lalu pasangkan elemen ke-i dengan elemen ke-i.

---

## âœ… Implementasi C++:

```cpp
class Solution {
public:
    int minMovesToSeat(vector<int>& seats, vector<int>& students) {
        sort(seats.begin(), seats.end());
        sort(students.begin(), students.end());

        int totalMoves = 0;
        for (int i = 0; i < seats.size(); i++) {
            totalMoves += abs(seats[i] - students[i]);
        }

        return totalMoves;
    }
};
```

---

## â±ï¸ Kompleksitas:

| Jenis          | Kompleksitas                           |
| -------------- | -------------------------------------- |
| Waktu (Time)   | $O(n\;log\;n)$ â†’ karena 2 kali sorting |
| Memori (Space) | $O(1)$ â†’ tidak pakai struktur tambahan |

# Informasi tambahan
Fungsi `abs()` berasal dari header `<cmath>`, berguna untuk mengambil selisih dari dua bilangan yang dioperasikan, dengan nilai yang selalu positif. Seperti mutlak dalam matematika.

```cpp
int rest = abs(var1 - var2);
// rest akan selalu menerima bilangan positif
```