---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0001
judul_problem: Waktu Minimum Mengetik Kata Menggunakan Mesin Ketik Khusus
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ  O(n)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-14T23:54:00
pendekatan: greedy algorithm
tags:
  - greedy
  - string
---
Link problem: [Minimum Time to Type Word Using Special Typewriter - LeetCode](https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/description/?envType=problem-list-v2&envId=greedy)

#greedy #string

---
# Waktu Minimum Mengetik Kata Menggunakan Mesin Ketik Khusus
Time limit: -
Memory limit: -

![[06PS-GAPS-0001-1.png]]

Terdapat sebuah mesin ketik khusus dengan huruf kecil alfabet Inggris dari `'a'` hingga `'z'` yang disusun melingkar dengan sebuah penunjuk (_pointer_). Sebuah karakter hanya bisa diketik jika penunjuk sedang menunjuk ke karakter tersebut. Penunjuk awalnya menunjuk ke karakter `'a'`.

Setiap detik, kamu dapat melakukan salah satu dari operasi berikut:

- Menggerakkan penunjuk satu karakter searah jarum jam (_clockwise_) atau berlawanan arah jarum jam (_counterclockwise_).
- Mengetik karakter yang saat ini sedang ditunjuk oleh penunjuk.

Diberikan sebuah string `word`, kembalikan jumlah detik minimum untuk mengetik seluruh karakter dalam `word`.

---

### Contoh 1:

**Input**: `word = "abc"`  
**Output**: `5`  
**Penjelasan**:  
Karakter diketik sebagai berikut:

- Ketik karakter `'a'` dalam 1 detik karena penunjuk awalnya berada pada `'a'`.
- Gerakkan penunjuk searah jarum jam ke `'b'` dalam 1 detik.
- Ketik karakter `'b'` dalam 1 detik.
- Gerakkan penunjuk searah jarum jam ke `'c'` dalam 1 detik.
- Ketik karakter `'c'` dalam 1 detik.
### Contoh 2:

**Input**: `word = "bza"`  
**Output**: `7`  
**Penjelasan**:

- Gerakkan penunjuk searah jarum jam ke `'b'` dalam 1 detik.
- Ketik karakter `'b'` dalam 1 detik.
- Gerakkan penunjuk berlawanan arah jarum jam ke `'z'` dalam 2 detik.
- Ketik karakter `'z'` dalam 1 detik.
- Gerakkan penunjuk searah jarum jam ke `'a'` dalam 1 detik.
- Ketik karakter `'a'` dalam 1 detik.

### Contoh 3:

**Input**: `word = "zjpc"`  
**Output**: `34`  
**Penjelasan**:

- Gerakkan penunjuk berlawanan arah jarum jam ke `'z'` dalam 1 detik.
    
- Ketik karakter `'z'` dalam 1 detik.
    
- Gerakkan penunjuk searah jarum jam ke `'j'` dalam 10 detik.
    
- Ketik karakter `'j'` dalam 1 detik.
    
- Gerakkan penunjuk searah jarum jam ke `'p'` dalam 6 detik.
    
- Ketik karakter `'p'` dalam 1 detik.
    
- Gerakkan penunjuk berlawanan arah jarum jam ke `'c'` dalam 13 detik.
    
- Ketik karakter `'c'` dalam 1 detik.
    

---

### Batasan:

- `1 <= word.length <= 100`
    
- `word` terdiri dari huruf kecil alfabet Inggris.
    


# Jawaban
Versi awal:

```cpp
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

int minTimeToType(string word) {
    int time = 0;
    char current = 'a';

    for (char c : word) {
        int diff = abs(c - current);
        // Karena huruf disusun melingkar (26 huruf),
        // kita ambil minimum dari arah searah atau berlawanan
        int minStep = min(diff, 26 - diff);
        time += minStep + 1; // +1 untuk mengetik hurufnya
        current = c;
    }

    return time;
}

int main() {
    string word;
    cin >> word;
    cout << minTimeToType(word) << endl;
    return 0;
}
```

Time complexity: $O(n)$
Memory complexity: $O(1)$
## Jawaban efektif
Jawaban awal sudah merupakan jawaban paling efisien.

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 
## ğŸ§  Kenapa ini masuk Greedy Algorithm?

Setiap kali kita mau mengetik huruf berikutnya, kita harus:

1. Menghitung **jarak tercepat** dari posisi saat ini ke huruf target.
2. Pilih apakah lebih cepat **searah jarum jam** atau **berlawanan arah jarum jam**.
3. Bergerak ke sana (itu adalah **keputusan greedy lokal**).
4. Ketik hurufnya.

Kita mengulangi proses ini untuk setiap huruf. Karena kita **selalu memilih pergerakan paling cepat** di setiap langkah, maka ini adalah pendekatan **greedy**.

## ğŸš€ Langkah-langkah Penyelesaian:

1. Mulai dari `'a'`.
2. Untuk setiap huruf dalam `word`, hitung:
    
    - Jarak maju (clockwise).
        
    - Jarak mundur (counterclockwise).
        
    - Ambil jarak yang minimum dari keduanya.
        
    - Tambahkan `1` untuk waktu mengetik hurufnya.
        
3. Update posisi pointer ke huruf saat ini.
    
4. Tambahkan waktu total.
    

# Informasi tambahan
## 1. Menghitung jarak huruf sekarang dengan huruf selanjutnya
Baris:

```cpp
int diff = abs(c - current);
```

punya **peran penting** dalam menghitung **jarak antara dua huruf** di mesin ketik melingkar. Mari kita bedah maksudnya:

---

### ğŸ§  Tujuan dari `abs(c - current)`

`c` = huruf tujuan  
`current` = huruf tempat pointer berada sekarang

Karena huruf-huruf `'a'` sampai `'z'` punya **urutan ASCII** yang berurutan, maka:

- `'a'` = 97
    
- `'b'` = 98
    
- `'c'` = 99
    
- ...
    
- `'z'` = 122
    

Maka `c - current` secara otomatis memberi tahu kita **berapa langkah maju (searah jarum jam)** dari `current` ke `c`.

Tapi, karena kadang `c` bisa sebelum `current` (contoh: dari `'z'` ke `'a'`), maka `c - current` bisa negatif.

â¡ï¸ **`abs(c - current)`** memastikan hasilnya selalu **positif**, yaitu **jumlah langkah mentah (tanpa arah)**.

---

### ğŸ“˜ Contoh:

### Dari `'a'` ke `'c'`:

```cpp
c = 'c'       // 99
current = 'a' // 97
diff = abs(99 - 97) = 2
```

â¡ï¸ 2 langkah searah jarum jam

### Dari `'c'` ke `'a'`:

```cpp
c = 'a'       // 97
current = 'c' // 99
diff = abs(97 - 99) = 2
```

â¡ï¸ 2 langkah berlawanan arah jarum jam

---

### ğŸ“Tapi... Ini Belum Final!

Ingat: huruf-huruf disusun **melingkar**, jadi setelah `'z'` akan balik ke `'a'`.

Makanya nanti kita juga pakai:

```cpp
int minStep = min(diff, 26 - diff);
```

Artinya:

- Pilih **jarak lebih pendek**: apakah kita jalan searah atau berlawanan arah jarum jam?
    

---

### ğŸ§  Kesimpulan:

Baris `abs(c - current)` adalah untuk menghitung **jarak linear** antara dua huruf, yang akan dibandingkan dengan `26 - diff` untuk mendapatkan **jarak rotasi minimum** dalam lingkaran alfabet.
