---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0005
judul_problem: Biaya Minimum Membeli Permen dengan Diskon
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ¤ O(n log n)
memory_complexity: 
status: ğŸ† solved
date_solved: 2025-04-15T22:32:00
pendekatan: greedy algorithm
tags:
  - array
  - greedy
---
Link problem: [Minimum Cost of Buying Candies With Discount - LeetCode](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/?envType=problem-list-v2&envId=greedy)

#array #greedy 

---
# Biaya Minimum Membeli permen dengan Diskon
Time limit: -
Memory limit: -

Sebuah toko sedang menjual permen dengan diskon. Untuk **setiap dua permen yang dibeli**, toko memberikan **permen ketiga secara gratis**.

Pelanggan boleh memilih permen mana pun untuk dibawa pulang secara gratis **selama harga permen gratis tersebut kurang dari atau sama dengan harga termurah dari dua permen yang dibeli**.

> Contohnya, kalau ada 4 permen dengan harga 1, 2, 3, dan 4, dan pelanggan membeli permen dengan harga 2 dan 3, maka mereka bisa mengambil permen dengan harga 1 secara gratis, **tapi tidak bisa mengambil permen yang harganya 4**.

Diberikan array integer `cost` (berbasis indeks 0), di mana `cost[i]` menunjukkan harga dari permen ke-i.  
**Kembalikan total biaya minimum** untuk membeli semua permen.

---

### Contoh 1:

**Input:**  
`cost = [1,2,3]`  
**Output:** `5`  
**Penjelasan:**  
Kita beli permen harga 2 dan 3 â†’ ambil gratis yang harga 1.  
Total biaya = 2 + 3 = **5**  
(Ini satu-satunya cara agar dapat semua permen.)

---

### Contoh 2:

**Input:**  
`cost = [6,5,7,9,2,2]`  
**Output:** `23`  
**Penjelasan:**  
Cara paling hemat:

- Beli 9 dan 7
    
- Ambil 6 gratis
    
- Beli 5 dan 2
    
- Ambil 2 gratis  
    Total: 9 + 7 + 5 + 2 = **23**
    

---

### Contoh 3:

**Input:**  
`cost = [5,5]`  
**Output:** `10`  
**Penjelasan:**  
Cuma ada 2 permen â†’ gak bisa dapat yang gratis.  
Jadi totalnya 5 + 5 = **10**

---

### Batasan:

- `1 <= cost.length <= 100`
    
- `1 <= cost[i] <= 100`
    

# Jawaban
Jawaban yang sudah paling efektif:

```cpp
class Solution {
public:
    int minimumCost(vector<int>& cost) {
        sort(cost.begin(), cost.end(), greater<int>());

        int totalCost=0;

        for(int i=0; i<cost.size(); i++){
            if(i % 3 != 2){
                totalCost+=cost[i];
            }
        }

        return totalCost;
    }
};
```

Time complexity: $O(n\;log\;n)$
Memory complexity: $O()$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 

### ğŸ§  Intuisi

Agar total biaya seminimal mungkin, kita ingin **mendapatkan candy termahal secara gratis** sebisa mungkin.

Namun karena aturan free-nya adalah:

> _"Untuk setiap 2 permen yang dibeli, dapat 1 gratis (dengan syarat harga permen gratis â‰¤ harga termurah dari 2 yang dibeli)"_  
> ...maka pendekatan terbaik adalah:

> **Sort harga dari yang paling mahal**, lalu ambil 2 paling mahal untuk dibeli, dan skip 1 (gratis), lalu lanjut lagi 2 beli, skip 1, dst.

Dengan cara ini, kita **selalu mendapatkan permen yang paling mahal secara gratis** (sesuai syarat yang diberikan).

---

### âœ… Langkah-langkah

1. Urutkan `cost` dari besar ke kecil.
    
2. Inisialisasi `totalCost = 0`.
    
3. Loop:
    
    - Untuk setiap 3 permen: beli 2 yang pertama, lewati 1 (gratis).
        
4. Jumlahkan semua permen yang **tidak dilewati**.
    

---

### ğŸ’¡ Implementasi C++

```cpp
int minimumCost(vector<int>& cost) {
    sort(cost.begin(), cost.end(), greater<int>()); // Urut dari besar ke kecil
    int totalCost = 0;
    
    for (int i = 0; i < cost.size(); ++i) {
        // Setiap 3 elemen, lewati yang ke-3 (gratis)
        if (i % 3 != 2) {
            totalCost += cost[i];
        }
    }
    
    return totalCost;
}
```

---

### â±ï¸ Kompleksitas Waktu

- **O(n log n)** untuk sorting.
    
- **O(n)** untuk loop menghitung biaya.
    

---

### ğŸ“Œ Contoh

Untuk `cost = [6,5,7,9,2,2]`  
Disortir jadi: `[9, 7, 6, 5, 2, 2]`  
Loop:

- Ambil 9 + 7
    
- Lewati 6 (gratis)
    
- Ambil 5 + 2
    
- Lewati 2 (gratis)  
    Total = 9 + 7 + 5 + 2 = **23**
    

# Informasi tambahan
Apa kegunaan dari:

```cpp
if (i % 3 != 2) {
```

Wah, pertanyaan mantap! ğŸ‘€ Itu `if (i % 3 != 2)` sering muncul di solusi soal diskon permen ini. Yuk kita bedah bareng-bareng kenapa muncul kondisi itu:

---

### ğŸ’¡ Ide utama solusi:

Kita **sort** array `cost` dari **termahal ke termurah**, karena:

> Kalau kita mau beli dua permen, lalu dapet satu gratis, tentu kita ingin **permen gratis itu yang termurah**, bukan yang mahal.

---

### ğŸ” Pola pembelian (dalam grup 3):

Misal `cost` setelah di-sort:  
`[9, 7, 6, 5, 2, 2]`  
Kita akan beli seperti ini:

|Index|Harga|Aksi|
|---|---|---|
|0|9|beli|
|1|7|beli|
|2|6|**gratis**|
|3|5|beli|
|4|2|beli|
|5|2|**gratis**|

---

### ğŸš© Nah, kenapa `i % 3 != 2`?

Karena:

- **Setiap 3 item**, item ke-3 (indeks 2, 5, 8, dst) adalah permen yang kita anggap **gratis**.
    
- Jadi:
    
    - Kalau `i % 3 == 0` â†’ beli
        
    - Kalau `i % 3 == 1` â†’ beli
        
    - Kalau `i % 3 == 2` â†’ **jangan tambahkan ke total, ini permen gratis!**
        

---

### ğŸ§  Jadi:

```cpp
if (i % 3 != 2) {
    total += cost[i]; // cuma beli permen pertama dan kedua dari setiap 3
}
```

### Ohh oke

> ohhh, oh ya yah, kan dimulai dari 0, aku bingung karena membayang dimulai dari 1, jadi, loh kok 3%3!=2 haha

HAHA iyaaa, itu jebakan klasik banget ğŸ¤£  
Kalau lagi bayangin urutan mulai dari 1, terus baca `i % 3 == 2`, memang kerasa aneh. Tapi karena array di C++/Java/Python semuanya **0-based indexing**, jadi:

|Index (i)|Urutan ke|i % 3|Status|
|---|---|---|---|
|0|ke-1|0|beli|
|1|ke-2|1|beli|
|2|ke-3|2|**gratis**|
|3|ke-4|0|beli|
|4|ke-5|1|beli|
|5|ke-6|2|**gratis**|
|...|...|...|...|

Tapi enaknya juga kalau udah tahu, bisa dengan percaya diri bilang:  
**â€œPokoknya setiap 3 item, yang ke-3 (modulo 3 == 2) itu gratis.â€** ğŸ˜

