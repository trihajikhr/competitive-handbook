---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0006
judul_problem: Jumlah minimal empat digit Angka setelah dibagi digit
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ¢ O(1)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-15T23:09:00
pendekatan: greedy algorithm
tags:
  - array
  - greedy
---
Link problem: [Minimum Sum of Four Digit Number After Splitting Digits - LeetCode](https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/description/?envType=problem-list-v2&envId=greedy)

#array #greedy 

---
# Jumlah minimal empat digit Angka setelah dibagi digit
Time limit: -
Memory limit: -

Diberikan sebuah bilangan bulat positif `num` yang terdiri dari tepat empat digit. Pisahkan `num` menjadi dua bilangan bulat baru, `new1` dan `new2`, dengan menggunakan digit-digit yang ada di dalam `num`. Angka nol di depan diizinkan pada `new1` dan `new2`, dan semua digit yang ada di dalam `num` harus digunakan.

Sebagai contoh, jika diberikan `num = 2932`, Anda memiliki digit-digits: dua angka 2, satu angka 9, dan satu angka 3. Beberapa pasangan `[new1, new2]` yang mungkin adalah `[22, 93]`, `[23, 92]`, `[223, 9]`, dan `[2, 329]`.

Kembalikan jumlah terkecil yang mungkin dari `new1` dan `new2`.

### Contoh 1:

**Input:** `num = 2932` 
**Output:** 52  
**Penjelasan:** Beberapa pasangan `[new1, new2]` yang mungkin adalah `[29, 23]`, `[223, 9]`, dll.  
Jumlah terkecil dapat diperoleh dengan pasangan `[29, 23]`: 29 + 23 = 52.

### Contoh 2:

**Input:** `num = 4009`  
**Output:** 13  
**Penjelasan:** Pasangan terbaik adalah `[4, 9]`: 4 + 9 = 13.

### Batasan:

- 1000 <= num <= 9999

---
# Jawaban
Jawaban yang sudah cukup efektif secara kompleksitas: 

```cpp
class Solution {
public:
    int minimumSum(int num) {
        vector<int> digits;

        while(num>0){
            digits.push_back(num % 10);
            num /= 10;
        }

        sort(digits.begin(), digits.end());

        int New1 = digits[0] * 10 + digits[2];
        int New2 = digits[1] * 10 + digits[3];
        

        return New1 + New2;
    }
};
```

Time complexity: $O(1)$
Memory complexity: $O(1)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 
Soal ini meminta kita untuk membagi angka empat digit menjadi dua angka baru, kemudian mencari jumlah terkecil dari kedua angka tersebut. Digits yang ada dalam angka harus digunakan semuanya, dan leading zero diizinkan.

### Penyelesaian:

Langkah-langkah untuk menyelesaikan soal ini adalah:

1. **Pisahkan Angka Menjadi Digits**: Pisahkan digit-digits dari angka 4 digit yang diberikan.
    
2. **Sortir Angka**: Setelah memisahkan angka, kita urutkan digitnya. Ini penting agar kita bisa membagi angka secara optimal. Dengan mengurutkan digit, kita bisa memastikan bahwa pembagian angka yang paling kecil (misalnya, membagi digit terkecil ke dalam satu angka dan yang lebih besar ke angka lainnya) bisa menghasilkan jumlah terkecil.
    
3. **Pilih Pasangan yang Tepat**: Pisahkan digit yang sudah diurutkan menjadi dua angka (`new1` dan `new2`) dan hitung jumlahnya. Pastikan angka yang dibentuk adalah valid dengan menggunakan seluruh digit yang ada.
    
4. **Cek Semua Kombinasi**: Cobalah kombinasi yang berbeda dan pilih kombinasi yang menghasilkan jumlah terkecil.
    

### Implementasi:

```cpp
class Solution {
public:
    int minimumSum(int num) {
        vector<int> digits;

        // Ambil setiap digit
        while (num > 0) {
            digits.push_back(num % 10);
            num /= 10;
        }

        // Urutkan digit
        sort(digits.begin(), digits.end());

        // Gabungkan jadi dua angka kecil
        int new1 = digits[0] * 10 + digits[2];
        int new2 = digits[1] * 10 + digits[3];

        return new1 + new2;
    }
};
```

### Penjelasan:

- Ambil semua digit dari angka 4 digit
    
- Urutkan dari terkecil ke terbesar
    
- Bentuk dua angka dari kombinasi digit terkecil agar jumlahnya minimum
    
- Misal: dari `[0, 1, 2, 9]` bisa jadi `02 + 19 = 21`
    

### Contoh:

#### Contoh 1:

Input: `num = 2932`

- Pisahkan digit: `[2, 2, 3, 9]`
    
- Setelah diurutkan: `[2, 2, 3, 9]`
    
- Pasangan angka: `new1 = 29`, `new2 = 23`
    
- Jumlah: `29 + 23 = 52`
    

Output: `52`

#### Contoh 2:

Input: `num = 4009`

- Pisahkan digit: `[0, 4, 9, 0]`
    
- Setelah diurutkan: `[0, 0, 4, 9]`
    
- Pasangan angka: `new1 = 04 (4)`, `new2 = 09 (9)`
    
- Jumlah: `4 + 9 = 13`
    

Output: `13`

### Kompleksitas waktu

- Waktu: O(1), karena ukuran input selalu tetap (4 digit). 
- Ruang: O(1), hanya memerlukan ruang untuk menyimpan digit. 

Dengan pendekatan ini, kita bisa menemukan jumlah terkecil dengan efisien.
# Informasi tambahan