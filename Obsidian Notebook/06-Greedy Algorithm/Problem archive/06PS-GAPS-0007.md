---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0007
judul_problem: Hapus digit dari angka untuk memaksimalkan hasil
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ  O(n)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-15T23:42:00
pendekatan: greedy algorithm
tags:
  - array
  - greedy
---
Link problem: [Fetching Title#ax2a](https://leetcode.com/problems/remove-digit-from-number-to-maximize-result/description/?envType=problem-list-v2&envId=greedy)

#array #greedy 

---
# Hapus digit dari angka untuk memaksimalkan hasil
Time limit: -
Memory limit: -

Kamu diberikan sebuah string `number` yang merepresentasikan sebuah bilangan bulat positif dan sebuah karakter `digit`.

Kembalikan string hasil setelah menghapus **tepat satu** kemunculan dari `digit` dari `number` sehingga nilai string hasil tersebut dalam bentuk desimal menjadi **maksimum**. Kasus uji dijamin bahwa `digit` muncul **setidaknya sekali** dalam `number`.

---

### Contoh 1:

**Input:**  `number = "123"`, `digit = "3"`  
**Output:** `"12"`  
**Penjelasan:**  
Hanya ada satu '3' dalam "123". Setelah menghapus '3', hasilnya adalah "12".

---

### Contoh 2:

**Input:**  
`number = "1231"`, `digit = "1"`  
**Output:** `"231"`  
**Penjelasan:**  
Kita bisa menghapus '1' pertama dan mendapatkan "231" atau menghapus '1' kedua dan mendapatkan "123".  
Karena 231 > 123, kita kembalikan "231".

---

### Contoh 3:

**Input:**  
`number = "551"`, `digit = "5"`  
**Output:** `"51"`  
**Penjelasan:**  
Kita bisa menghapus '5' pertama atau kedua dari "551".  
Keduanya menghasilkan string "51".

---

### Batasan:

- `2 <= number.length <= 100`
    
- `number` terdiri dari digit antara `'1'` hingga `'9'`.
    
- `digit` adalah sebuah digit dari `'1'` hingga `'9'`.
    
- `digit` muncul **setidaknya satu kali** dalam `number`.

---
# Jawaban
Jawaban awal:

```cpp
class Solution {
public:
    string removeDigit(string number, char digit) {
        string maxRest="";

        for(int i=0; i <number.size(); ++i){
            if(number[i] == digit){
                string temp = number.substr(0,i) + number.substr(i+1);

                if(temp > maxRest){
                    maxRest = temp;
                }
            }
        }

        return maxRest;
    }
};
```

Time complexity: $O(n)$
Memory complexity: $O(1)$
## Jawaban efektif
Jawaban ini dapat berjalan dalam 0 ms, lebih cepat daripada jawaban sebelumnya:

```cpp
class Solution {
public:
    string removeDigit(string s, char digit) {
        int n=s.size();
        for(int i=0;i<n-1;i++){
            if(s[i]==digit && s[i+1]>digit){
                return s.substr(0,i)+s.substr(i+1,n);
            }
        }
        for(int i=n-1;i>=0;i--){
            if(s[i]==digit)return s.substr(0,i)+s.substr(i+1,n);
        }
        return s;
    }
};
```

Time complexity: $O()$
Memory complexity: $O()$

Versi ini **lebih optimal secara greedy** dan lebih efisien dibanding solusi brute-force. Berikut penjelasanya:

### ğŸ” Penjelasan Strateginya:

Kita ingin **menghapus satu `digit`** dari string `s` agar hasil akhirnya **maksimal secara nilai desimal**.

#### Langkah logikanya:

1. **Cari kemunculan `digit`** sedemikian rupa sehingga **angka setelahnya lebih besar dari `digit`** (misalnya: `2 < 3`).
    
    - Kalau `s[i] == digit` dan `s[i+1] > digit`, maka **hapus `s[i]`**, karena angka setelahnya lebih besar â†’ hasil jadi lebih besar!
        
    - Ini greedy banget: cari posisi pertama di mana `digit` "menghalangi" angka besar setelahnya.
        
2. Kalau tidak ada kondisi seperti itu, berarti semua `digit` setelahnya tidak lebih besar, maka:
    
    - **hapus `digit` yang paling akhir** saja.
        

---

### ğŸ’¡ Kenapa Strategi Ini Benar?

- Misalnya `"1231"` dan kita hapus `'1'`.  
    Dua opsi:
    
    - Hapus indeks `0`: hasil `"231"`
        
    - Hapus indeks `3`: hasil `"123"`
        
    - `"231" > "123"` â†’ maka strategi kita akan pilih hapus yang pertama.
        

Dan logikamu tepat menangani itu! ğŸ§ ğŸ”¥

---

### âœ… Kompleksitas:

- **Waktu:** `O(n)` â†’ hanya satu kali traversal dari kiri dan satu kali dari kanan.
    
- **Ruang:** `O(1)` (selain hasil string baru).
    

# Editorial 
Berikut adalah solusi untuk soal tersebut dalam **C++**:

```cpp
class Solution {
public:
    string removeDigit(string number, char digit) {
        string maxResult = "";

        for (int i = 0; i < number.size(); ++i) {
            if (number[i] == digit) {
                // Buat string baru dengan menghapus karakter pada indeks i
                string temp = number.substr(0, i) + number.substr(i + 1);
                // Ambil string maksimum secara leksikografis (dan otomatis dalam konteks angka, nilainya juga maksimum)
                if (temp > maxResult) {
                    maxResult = temp;
                }
            }
        }

        return maxResult;
    }
};
```

### Penjelasan:

- Kita melakukan iterasi pada setiap karakter dalam string `number`.
    
- Jika karakter saat ini sama dengan `digit` yang ingin dihapus, kita coba hapus karakter tersebut.
    
- Setelah menghapus, kita simpan hasilnya jika hasil tersebut lebih besar daripada hasil sebelumnya (`maxResult`).
    
- Akhirnya kita kembalikan hasil terbaik.
    

---

### Kompleksitas:

- **Waktu:** `O(n)`, di mana `n` adalah panjang dari string `number` (maksimal 100).
    
- **Ruang:** `O(1)` untuk ruang tambahan, tapi `O(n)` digunakan untuk menyimpan string hasil.
    

Kalau siap, kita lanjut ke soal berikutnya!
# Informasi tambahan