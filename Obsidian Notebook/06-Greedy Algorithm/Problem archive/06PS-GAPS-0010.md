---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0010
judul_problem: Jadikan Array nol dengan mengurangi dengan angka yang sama
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ  O(n)
memory_complexity: ğŸŸ  O(n)
status: ğŸ† solved
date_solved: 2025-04-16T10:15:00
pendekatan: 
tags:
  - array
  - greedy
  - sorting
  - heap
  - hash-table
---
Link problem: [Make Array Zero by Subtracting Equal Amounts - LeetCode](https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/description/?envType=problem-list-v2&envId=greedy)

#array #greedy #sorting #heap #hash-table

---
# Jadikan Array nol dengan mengurangi dengan angka yang sama
Time limit: -
Memory limit: -

Diberikan sebuah array integer non-negatif `nums`. Dalam satu operasi, kamu **harus**:

- Memilih sebuah bilangan bulat positif `x` sedemikian sehingga `x` **kurang dari atau sama dengan** elemen bukan nol terkecil dalam `nums`.
    
- Mengurangkan `x` dari setiap elemen positif dalam `nums`.
    

Kembalikan **jumlah operasi minimum** untuk membuat setiap elemen dalam `nums` menjadi 0.

---

### Contoh 1:

**Input:** `nums = [1,5,0,3,5]`  
**Output:** `3`  
**Penjelasan:**

- Operasi pertama, pilih `x = 1`. Maka `nums = [0,4,0,2,4]`.
    
- Operasi kedua, pilih `x = 2`. Maka `nums = [0,2,0,0,2]`.
    
- Operasi ketiga, pilih `x = 2`. Maka `nums = [0,0,0,0,0]`.

---

### Contoh 2:

**Input:** `nums = [0]`  
**Output:** `0`  
**Penjelasan:** Setiap elemen di `nums` sudah 0, jadi tidak diperlukan operasi apa pun.

---

### Batasan:

- `1 <= nums.length <= 100`
    
- `0 <= nums[i] <= 100`

# Jawaban
Jawaban ini sudah cukup cepat untuk berjalan di 0 ms runtime:

```cpp
class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        unordered_set<int> s;
        for (int x : nums) {
            if (x != 0) s.insert(x);
        }
        return s.size();
    }
};
```

Time complexity: $O(n)$
Memory complexity: $O(n)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 
Berikut solusi C++ untuk masalah tersebut, menggunakan pendekatan sederhana namun optimal:

```cpp
class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        unordered_set<int> s;
        for (int x : nums) {
            if (x != 0) s.insert(x);
        }
        return s.size();
    }
};
```

---

### ğŸ” Penjelasan:

- **Tujuan:** Hitung berapa kali kita perlu mengurangi elemen-elemen positif di `nums` hingga semuanya menjadi nol.
    
- Karena setiap operasi **mengurangi nilai dari semua elemen positif** berdasarkan elemen terkecil yang belum nol, maka jumlah operasi yang dibutuhkan akan sama dengan **jumlah elemen unik yang bukan nol**.
    
- Maka kita cukup:
    
    1. **Memasukkan semua elemen bukan nol ke dalam `unordered_set`** (untuk menghilangkan duplikat).
        
    2. **Mengembalikan ukuran set tersebut** sebagai jumlah operasi minimum.
        

---

### ğŸ§  Kompleksitas:

- **Waktu:** `O(n)` â€” melakukan satu kali iterasi terhadap seluruh array.
    
- **Ruang:** `O(n)` dalam kasus terburuk, jika semua elemen berbeda dan bukan nol.
    

# Informasi tambahan