---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0009
judul_problem: Jumlah waktu Minimum untuk Mengisi Cangkir
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ¢ O(1)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-16T08:18:00
pendekatan: greedy algorithm
tags:
  - array
  - greedy
  - sorting
  - heap
---
Link problem: [Minimum Amount of Time to Fill Cups - LeetCode](https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/description/?envType=problem-list-v2&envId=greedy)

#array #greedy #sorting #heap 

---
# Jumlah waktu Minimum untuk Mengisi Cangkir
Time limit: -
Memory limit: -


Kamu memiliki sebuah dispenser air yang dapat mengeluarkan **air dingin**, **hangat**, dan **panas**.  
Setiap **detik**, kamu dapat melakukan salah satu dari dua pilihan:

1. Mengisi **2 gelas** air dengan **jenis air yang berbeda**, **atau**
    
2. Mengisi **1 gelas** air dari **jenis apapun**.
    

---

Diberikan sebuah array integer `amount` berukuran 3, di mana:

- `amount[0]` adalah jumlah gelas **air dingin** yang perlu diisi,
    
- `amount[1]` adalah jumlah gelas **air hangat** yang perlu diisi,
    
- `amount[2]` adalah jumlah gelas **air panas** yang perlu diisi.
    

---

**Tugasmu**:  
Kembalikan **jumlah detik minimum** yang dibutuhkan untuk **mengisi semua gelas**.

---

### Contoh:

#### Contoh 1

**Input**:  
`amount = [1, 4, 2]`  
**Output**:  
`4`

**Penjelasan**:

- Detik 1: isi air dingin + air hangat
    
- Detik 2: isi air hangat + air panas
    
- Detik 3: isi air hangat + air panas
    
- Detik 4: isi air hangat
    

---

#### Contoh 2

**Input**:  
`amount = [5, 4, 4]`  
**Output**:  
`7`

**Penjelasan** (salah satu cara optimal):

- Detik 1: dingin + panas
    
- Detik 2: dingin + hangat
    
- Detik 3: dingin + hangat
    
- Detik 4: hangat + panas
    
- Detik 5: dingin + panas
    
- Detik 6: dingin + hangat
    
- Detik 7: panas
    

---

#### Contoh 3

**Input**:  
`amount = [5, 0, 0]`  
**Output**:  
`5`

**Penjelasan**:  
Hanya bisa mengisi 1 gelas dingin per detik.

---

### Batasan:

- `amount.length == 3`
    
- `0 <= amount[i] <= 100`
    
# Jawaban
// penjelasan singkat

```cpp
class Solution {
public:
    int fillCups(vector<int>& amount) {
        sort(amount.begin(), amount.end(), greater<int>());
        int total = amount[0] + amount[1] + amount[2];
        return max(amount[0], (total + 1) / 2);
    }
};
```

Time complexity: $O()$
Memory complexity: $O()$
## Jawaban efektif
// penjelasan singkat

```cpp
class Solution {
public:
    int fillCups(vector<int>& amount) {
        sort(amount.begin(),amount.end());
        int ans = 0;
        int min=amount[0],mid=amount[1],max=amount[2];
        while(min+mid>max){
            min--;
            mid--;
            ans++;
        }
        ans+=max;
        return ans;
    }
};
```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 
## âœ… Intuisi:

Setiap detik, kita bisa:

- Mengisi 2 gelas dari **jenis yang berbeda**, atau
    
- Mengisi 1 gelas dari **jenis apapun**.
    

Jadi, kita ingin **meminimalkan jumlah detik** untuk menghabiskan semua `amount`.

### ğŸ’¡ Strategi:

1. **Sortir `amount` secara menurun**, jadi `amount[0]` selalu yang terbesar.
    
2. Dalam satu detik, kita selalu bisa **mengisi dua gelas berbeda** â€” jadi kita fokus kurangi dua yang paling besar secara bersamaan.
    
3. Namun, kita tidak bisa mengisi lebih dari 2 gelas per detik, jadi jumlah detik **minimal** adalah:
    
    - `max(ceil(total / 2), max(amount))`
        
    - Tapi kita bisa sederhanakan jadi:  
        `max(max(amount), (sum(amount) + 1) // 2)`
        

Kenapa `(sum + 1) // 2`? Karena jika total 7 gelas, paling cepat bisa diselesaikan dalam 4 detik (karena 2 gelas per detik).

---

## ğŸ§  Kode C++:

```cpp
class Solution {
public:
    int fillCups(vector<int>& amount) {
        sort(amount.begin(), amount.end(), greater<int>());
        int total = amount[0] + amount[1] + amount[2];
        return max(amount[0], (total + 1) / 2);
    }
};
```

---

### ğŸ•’ Kompleksitas Waktu:

- `O(1)` karena panjang `amount` selalu 3. Sorting tetap `O(1)`.
    

### ğŸ§  Kompleksitas Memori:

- `O(1)` juga, karena tidak pakai struktur data tambahan signifikan.
    

---

Kalau kamu mau versi tanpa `sort`, bisa juga seperti ini:

```cpp
class Solution {
public:
    int fillCups(vector<int>& amount) {
        int total = amount[0] + amount[1] + amount[2];
        int maxVal = max({amount[0], amount[1], amount[2]});
        return max(maxVal, (total + 1) / 2);
    }
};
```

Versi ini lebih efisien karena tidak perlu sort sama sekali.

# Informasi tambahan