---
obsidianUIMode: preview
note_type: problem set
id_problem: 06PS-GAPS-0008
judul_problem: Jumlah Operasi Minimum untuk Mengoperasi Waktu
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ¢ O(1)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-16T07:34:00
pendekatan: greedy algorithm
tags:
  - string
  - greedy
---
Link problem: [Minimum Number of Operations to Convert Time - LeetCode](https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/description/?envType=problem-list-v2&envId=greedy)

#string #greedy 

---
# Jumlah Operasi Minimum untuk Mengoperasi Waktu
Time limit: -
Memory limit: -

Kamu diberikan dua string `current` dan `correct` yang merepresentasikan waktu dalam format 24-jam.

Waktu dalam format 24-jam ditulis sebagai `"HH:MM"`, di mana `HH` berada dalam rentang 00 sampai 23, dan `MM` berada dalam rentang 00 sampai 59. Waktu paling awal adalah `00:00`, dan waktu paling akhir adalah `23:59`.

Dalam satu operasi, kamu bisa menambahkan `1`, `5`, `15`, atau `60` menit ke waktu `current`. Kamu dapat melakukan operasi ini sebanyak mungkin.

Kembalikan jumlah **minimum** operasi yang dibutuhkan untuk mengubah `current` menjadi `correct`.

---

**Contoh 1:**

Input: `current = "02:30"`, `correct = "04:35"`  
Output: `3`  
Penjelasan:  
Kita bisa mengubah `current` menjadi `correct` dalam 3 operasi sebagai berikut:

- Tambahkan 60 menit ke `current`, menjadi `"03:30"`.
    
- Tambahkan 60 menit lagi, menjadi `"04:30"`.
    
- Tambahkan 5 menit, menjadi `"04:35"`.
    

Dapat dibuktikan bahwa tidak mungkin mengubah `current` ke `correct` dalam kurang dari 3 operasi.

---

**Contoh 2:**

Input: `current = "11:00"`, `correct = "11:01"`  
Output: `1`  
Penjelasan:  
Kita hanya perlu menambahkan 1 menit ke `current`, sehingga jumlah minimum operasi adalah 1.

---

**Batasan:**

- `current` dan `correct` ditulis dalam format `"HH:MM"`.
    
- `current <= correct`.**

---
# Jawaban
Jawaban dengan runtime terkecil:

```cpp
class Solution {
public:
    int convertTime(string current, string correct) {
        int cur = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3));
        int cor = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3));
        int diff = cor - cur;

        int ops = 0;
        for (int d : {60, 15, 5, 1}) {
            ops += diff / d;
            diff %= d;
        }
        return ops;
    }
};
```

Time complexity: $O(1)$
Memory complexity: $O(1)$
## Jawaban efektif
Jawaban dengan memory complexity terkecil:

```cpp
class Solution {
public:
    int convertTime(string current, string correct) {
        int a=(current[1]-'0') + (current[0]-'0')*10;
        int b=(correct[1]-'0') + (correct[0]-'0')*10;
        int ans=0;
        a=a*60;
        b=b*60;
        a+=(current[4]-'0') + (current[3]-'0')*10;
        b+=(correct[4]-'0') + (correct[3]-'0')*10;
        int diff=0;
        if(a<=b)
        {
            diff=b-a;
        }
        else
        {
            diff=b + (24*60-a);
        }
        ans=diff/60;
        int y=diff%60;
        ans+=y/15;
        int x=y%15;
        ans+=(x/5);
        ans+=x%5;
        return ans;
    }
};
```

Time complexity: $O(1)$
Memory complexity: $O(1)$
# Editorial 
### ğŸ’¡ Intuisi:

Kita ingin mencari **selisih waktu** antara `current` dan `correct` dalam menit, lalu kita coba **kurangi selisih tersebut** dengan cara paling optimal menggunakan operasi yang tersedia: 60, 15, 5, dan 1 menit.

---

### âœ… Langkah-langkah:

1. Konversi `current` dan `correct` ke dalam jumlah **menit total** dari pukul `00:00`.
    
2. Hitung selisih waktu.
    
3. Gunakan **greedy approach** (mulai dari operasi terbesar) untuk mengurangi selisih tersebut.
    
4. Hitung berapa banyak operasi minimum yang dibutuhkan.
    

---

### ğŸ§  C++ Code:

```cpp
class Solution {
public:
    int convertTime(string current, string correct) {
        int cur = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3));
        int cor = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3));
        int diff = cor - cur;

        int ops = 0;
        for (int d : {60, 15, 5, 1}) {
            ops += diff / d;
            diff %= d;
        }
        return ops;
    }
};

```

---

### ğŸ” Contoh:

Input: `current = "02:30"`, `correct = "04:35"`

- current â†’ 150 menit
    
- correct â†’ 275 menit
    
- diff = 125
    
- 125 / 60 = 2 â†’ 2 operasi (sisa 5)
    
- 5 / 5 = 1 â†’ 1 operasi
    
- Total = **3 operasi**
    
# Informasi tambahan

```cpp
int convertTime(string current, string correct) {
```

â–¶ï¸ Ini adalah deklarasi fungsi `convertTime` yang menerima dua `string` (waktu sekarang dan waktu tujuan), dan mengembalikan sebuah `int` (jumlah operasi minimum).

---

```cpp
    int cur = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3));
```

â–¶ï¸ Mengubah string `current` (misal `"02:30"`) menjadi jumlah **menit sejak pukul 00:00**:

- `current.substr(0, 2)` â†’ ambil jam `"02"` â†’ `stoi(...)` jadi 2 â†’ dikali 60 = 120
    
- `current.substr(3)` â†’ ambil menit `"30"` â†’ `stoi(...)` = 30
    
- Jadi total: `2*60 + 30 = 150` menit
    

---

```cpp
    int cor = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3));
```

â–¶ï¸ Sama seperti di atas, tapi untuk waktu tujuan (`correct`), misalnya `"04:35"` â†’ jadi `4*60 + 35 = 275` menit

---

```cpp
    int diff = cor - cur;
```

â–¶ï¸ Hitung selisih waktu dalam menit antara waktu tujuan dan waktu sekarang  
Misal: `275 - 150 = 125`

---

```cpp
    int ops = 0;
```

â–¶ï¸ Inisialisasi penghitung operasi (`ops`) untuk mencatat berapa langkah yang dibutuhkan

---

```cpp
    for (int d : {60, 15, 5, 1}) {
```

â–¶ï¸ Lakukan iterasi dari langkah waktu terbesar ke terkecil. Artinya:

- Coba kurangi selisih (`diff`) dengan 60 menit dulu
    
- Lalu dengan 15 menit, 5 menit, dan terakhir 1 menit â¡ï¸ Tujuannya untuk **meminimalkan jumlah operasi**
    

---

```cpp
        ops += diff / d;
```

â–¶ï¸ Tambahkan berapa kali kita bisa menambahkan `d` menit ke `ops`  
Misal `diff = 125`, dan `d = 60` â†’ `125 / 60 = 2`, jadi `ops += 2`

---

```cpp
        diff %= d;
```

â–¶ï¸ Ambil sisa selisih setelah `d` menit diterapkan  
Misal setelah 2 kali 60: `125 % 60 = 5`, maka `diff` sekarang tinggal 5 menit

---

```cpp
    }
    return ops;
}
```

â–¶ï¸ Setelah semua iterasi, kembalikan nilai `ops` sebagai jawaban akhir (jumlah langkah minimum yang dibutuhkan)

---

### ğŸ’¡ Contoh Singkat:

Input:

```cpp
current = "02:30"
correct = "04:35"
```

Langkah:

- current: 150 menit
    
- correct: 275 menit
    
- diff = 125
    
- Gunakan: 60 + 60 + 5 â†’ total 3 langkah
    

## Mengubah Input menjadi angka
Pertanyaan bagus! Mari kita bongkar bagian ini:

```cpp
int cur = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3));
```

---

### ğŸ¯ Tujuan Baris Ini

Baris ini mengubah string waktu dari format `"HH:MM"` menjadi **total menit sejak pukul 00:00**. Misalnya `"02:30"` jadi `2*60 + 30 = 150` menit.

---

### ğŸ“˜ Penjelasan `substr(0, 2)`

`substr(pos, len)` adalah fungsi dari class `string` di C++ untuk mengambil substring dari posisi `pos` sepanjang `len` karakter.

Jadi:

- `current.substr(0, 2)` â†’ ambil karakter dari index **0** sebanyak **2** karakter.  
    Contoh:  
    `"02:30".substr(0, 2)` â†’ hasil: `"02"`
    
- `stoi(...)` mengubah string `"02"` menjadi angka 2
    

Kemudian kita kalikan dengan 60 untuk dapat total **menit dari jam**.

---

### ğŸ“˜ Penjelasan `substr(3)`

Kenapa 3?

Karena format `"HH:MM"` selalu seperti ini:

|Index|0|1|2|3|4|
|---|---|---|---|---|---|
|Char|H|H|:|M|M|

Jadi:

- `current.substr(3)` â†’ ambil karakter dari indeks **3** sampai akhir  
    `"02:30".substr(3)` â†’ hasil: `"30"`  
    `stoi("30")` â†’ hasil: `30`
    

---

### ğŸ¯ Maka:

```cpp
stoi(current.substr(0, 2)) * 60  // = jam Ã— 60
+ stoi(current.substr(3))        // = tambah menit
```

Contoh `"04:35"`:

- `substr(0, 2)` = `"04"` â†’ `stoi(...) = 4`
    
- `substr(3)` = `"35"` â†’ `stoi(...) = 35`
    
- Total menit = `4*60 + 35 = 275`
    
