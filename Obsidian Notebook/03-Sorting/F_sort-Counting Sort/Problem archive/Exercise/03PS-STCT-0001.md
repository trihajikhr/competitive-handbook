---
obsidianUIMode: preview
note_type: problem set
id_problem: 03PS-STCT-0001
judul_problem: Pengurutan dengan counting sort
sumber: chatgpt.com
kategori_problem: ğŸ¯ exercise
kesulitan: ğŸ¥‰ easy
time_complexity: âšªO(n * k)
memory_complexity: âšªO(n * k) âœ… â†’ Stable
status: ğŸ† solved
date_solved: 2025-04-26T11:57:00
pendekatan: couting sort
tags:
  - array
  - sorting
  - counting-sort
---
Link problem: 

#array #sorting #counting-sort 

---
# Pengurutan dengan counting sort
Time limit: -
Memory limit: -

Urutkan sebuah array yang dimasukan oleh user, dan pastiakn menggunakan algoritma counting sort. Algoritma ini juga harus bisa mengolah angka negatif. Urutan angka harus dalamm bentuk ascending.

### Input
- `n` untuk banyaknya array
- `data` untuk menampung nilai elemen array.
#### Input constraints
\-
### Output
Array yang tersusun dalam urutan ascending.
### Examples
Input:
```
5
5 3 0 -2 11
```

Output:
```bash
-2 0 3 5 11
```

### Note
Algoritma counting sort biasa tidak bisa menangani angka negatif, lakukan sedikit modifikasi pada algoritma agar bisa menangai hal tersebut!
# Jawaban
Jawaban ku:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void countingSortWithNegatives(vector<int>& arr) {
    if (arr.empty()) return;

    int minVal = *min_element(arr.begin(), arr.end());
    int maxVal = *max_element(arr.begin(), arr.end());

    int range = maxVal - minVal + 1;

    vector<int> count(range, 0);

    for (int num : arr) {
        count[num - minVal]++;
    }

    int index = 0;
    for (int i = 0; i < range; ++i) {
        while (count[i] > 0) {
            arr[index++] = i + minVal; 
            count[i]--;
        }
    }
}

int main() {
    int n; cin >> n;
    vector<int> data (n);
    for(int&x:data) cin >> x;
    
    
    cout << "Sebelum sort: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;

    countingSortWithNegatives(data);

    cout << "Setelah sort: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

Time complexity: $O()$
Memory complexity: $O()$
## Jawaban efektif


```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 

## ğŸ“˜ Editorial: Counting Sort dengan Dukungan Angka Negatif (C++)

### ğŸ“Œ Tujuan:

Mengimplementasikan algoritma **Counting Sort** yang dapat menangani **nilai negatif**, sesuatu yang tidak bisa dilakukan versi standar karena indeks array tidak bisa negatif.

---

### ğŸ“ Intuisi:

Counting Sort bekerja dengan menghitung frekuensi elemen-elemen array, lalu menyusunnya kembali berdasarkan jumlah tersebut. Namun karena Counting Sort memakai elemen sebagai **indeks array**, angka negatif akan menyebabkan error.  
**Solusinya**: geser seluruh elemen agar indeksnya menjadi non-negatif.

---

### ğŸ§  Langkah-langkah:

1. **Temukan nilai terkecil (`minVal`) dan terbesar (`maxVal`)** dari array.
    
2. **Hitung rentang** nilai yang dibutuhkan untuk array `count` â†’ yaitu `maxVal - minVal + 1`.
    
3. Buat array `count` berukuran `range` dan inisialisasi semua elemen ke 0.
    
4. Iterasi semua elemen dalam array asli, dan simpan frekuensi pada `count[num - minVal]`.
    
5. Susun ulang array asli berdasarkan data dari `count[]`:
    
    - Setiap indeks `i` dalam `count[]` mewakili nilai `i + minVal`.
        
    - Tulis kembali elemen ke array asli sebanyak frekuensinya.
        

---

### ğŸ§ª Contoh:

```cpp
vector<int> data = {4, -1, 2, -6, 8, 3, -2, 3, 1};
```

- `minVal = -6`, `maxVal = 8`
    
- Rentang: `15`, maka `count[15]`
    
- Frekuensi disimpan pada indeks yang sudah digeser (`num - minVal`)
    
- Susun ulang array dengan membaca `count[]` dari indeks 0 sampai akhir
    

---

### ğŸ’¡ Kelebihan:

- Bisa menangani angka **negatif dan positif**.
    
- Kompleksitas waktu tetap **O(n + k)**, di mana `k = maxVal - minVal + 1`.
    
- Lebih efisien dari sorting umum seperti quicksort jika `k` kecil dibanding `n`.
    

---

### ğŸ“Œ Kode Lengkap:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void countingSortWithNegatives(vector<int>& arr) {
    if (arr.empty()) return;

    int minVal = *min_element(arr.begin(), arr.end());
    int maxVal = *max_element(arr.begin(), arr.end());
    int range = maxVal - minVal + 1;

    vector<int> count(range, 0);

    for (int num : arr) {
        count[num - minVal]++;
    }

    int index = 0;
    for (int i = 0; i < range; ++i) {
        while (count[i] > 0) {
            arr[index++] = i + minVal;
            count[i]--;
        }
    }
}

int main() {
    vector<int> data = {4, -1, 2, -6, 8, 3, -2, 3, 1};

    cout << "Sebelum sort: ";
    for (int num : data) cout << num << " ";
    cout << endl;

    countingSortWithNegatives(data);

    cout << "Setelah sort: ";
    for (int num : data) cout << num << " ";
    cout << endl;

    return 0;
}
```

---

### ğŸ“š Catatan:

- Versi ini **belum stabil** (urutan elemen yang sama bisa berubah).
    
- Jika ingin versi **stabil**, diperlukan array `output[]` dan **prefix sum** pada `count[]`.
    

---

Kalau kamu mau versi stabilnya juga untuk disimpan bareng editorial ini, aku bisa bantu buatkan juga. Mau?
# Informasi tambahan

### ğŸ“„ Kode Lengkapnya (Referensi):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
```

#### â¤ `#include <iostream>`

- Digunakan untuk input/output: `cin`, `cout`, `endl`.
    

#### â¤ `#include <vector>`

- Menggunakan `std::vector` karena array ini fleksibel dan mudah dimanipulasi ukurannya.
    

#### â¤ `#include <algorithm>`

- Untuk fungsi `min_element()` dan `max_element()`.
    

---

### âœ¨ Fungsi: `countingSortWithNegatives`

```cpp
void countingSortWithNegatives(vector<int>& arr) {
    if (arr.empty()) return;
```

#### â¤ `if (arr.empty()) return;`

- **Cek cepat**: kalau `arr` kosong, langsung keluar dari fungsi.
    
- Mencegah error saat mengambil min/max dari array kosong.
    

---

```cpp
    int minVal = *min_element(arr.begin(), arr.end());
    int maxVal = *max_element(arr.begin(), arr.end());
```

#### â¤ Ambil nilai minimum dan maksimum dari array:

- `min_element()` dan `max_element()` mengembalikan _iterator_, maka perlu `*` untuk ambil nilainya.
    
- Nilai-nilai ini penting untuk menentukan ukuran array `count[]` secara **dinamis**.
    

---

```cpp
    int range = maxVal - minVal + 1;
```

#### â¤ Hitung **jumlah kemungkinan nilai berbeda**:

- Misal data `-5` sampai `3` â†’ `range = 3 - (-5) + 1 = 9`.
    
- Ini memastikan `count[]` cukup besar menampung semua nilai, termasuk negatif.
    

---

```cpp
    vector<int> count(range, 0);
```

#### â¤ Buat array `count` dengan panjang `range` dan isi awal nol.

- Kita gunakan `vector` karena ukuran `range` dihitung saat runtime.
    
- `count[i]` menyimpan frekuensi dari nilai `i + minVal`.
    

---

```cpp
    for (int num : arr) {
        count[num - minVal]++;
    }
```

#### â¤ Hitung frekuensi elemen dalam `arr`.

- `num - minVal` digunakan untuk menggeser indeks:
    
    - Karena `count` harus mulai dari 0, dan nilai dalam `arr` bisa negatif.
        
    - Contoh: jika `minVal = -5`, dan `num = -3`, maka `count[-3 - (-5)] = count[2]`.
        

---

```cpp
    int index = 0;
    for (int i = 0; i < range; ++i) {
        while (count[i] > 0) {
            arr[index++] = i + minVal; 
            count[i]--;
        }
    }
```

#### â¤ Bangun ulang array `arr` berdasarkan jumlah di `count[]`:

- Untuk setiap `i` dari 0 sampai `range-1`, selama `count[i]` > 0:
    
    - Tempatkan nilai asli `i + minVal` ke dalam array `arr`.
        
    - Kenapa `+ minVal`?
        
        - Karena indeks `i` mewakili nilai `i + minVal` dari data asli.
            
- Kita lakukan `count[i]--` untuk memastikan hanya menempatkan sebanyak frekuensinya.
    

---

### ğŸ§ª Fungsi `main()`

```cpp
int main() {
    int n; cin >> n;
    vector<int> data(n);
    for(int& x : data) cin >> x;
```

#### â¤ Input jumlah elemen (`n`) dan baca array ke `vector<int> data`.

---

```cpp
    cout << "Sebelum sort: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;
```

#### â¤ Tampilkan array sebelum disortir.

---

```cpp
    countingSortWithNegatives(data);
```

#### â¤ Panggil fungsi utama kita.

---

```cpp
    cout << "Setelah sort: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

#### â¤ Cetak array setelah disortir.

---

### âœ… Keunggulan Pendekatan Ini:

- **Efisien secara ruang dan waktu** untuk nilai-nilai dalam rentang terbatas.
    
- Menangani **angka negatif** tanpa perlu struktur data kompleks.
    
- Tidak menghitung posisi kumulatif (karena langsung menulis berdasarkan frekuensi) â†’ lebih ringan untuk banyak kasus.
    

---

Kalau kamu ingin aku buatkan ini dalam format **editorial** atau Markdown-style untuk kamu simpan di Obsidian, tinggal bilang ya! Mau?