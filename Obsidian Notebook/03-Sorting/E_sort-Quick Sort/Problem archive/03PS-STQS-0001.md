---
obsidianUIMode: preview
note_type: problem set
id_problem: 03PS-STQS-0001
judul_problem: Implementasi quick sort
sumber: chatgpt.com
kategori_problem: ğŸ¯ exercise
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ¤ O(n log n) > ğŸŸ¤ O(n log n) > ğŸŸ£ O(nÂ²)
memory_complexity: ğŸŸ¢ O(1) âŒ â†’ Unstable
status: ğŸ† solved
date_solved: 2025-04-19T01:53:00
pendekatan: quick sort
tags:
  - array
  - sorting
  - quick-sort
---
Link problem: 

#array #sorting #quick-sort 

---
# Dasar Quick Sort
Time limit: -
Memory limit: -

Diberikan sebuah array acak, sorting atau urutkan dalam urusan ascending, menggunakan algoritma Quick sort.

### Input
- `n` untuk banyaknya array
- Baris kedua berisi nilai array
#### Input constraints
\-
### Output
Array yang sudah terurut.
### Examples
Input:
```
5
5 3 4 1 -2
```

Output:
```bash
-2 1 3 4 5
```

### Note
Lakukan sorting ini dengan menggunakan algoritma Quick Sort.
# Jawaban
Implementasi dasar quick sort:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // ambil pivot dari elemen terakhir
    int i = low - 1;

    for(int j = low; j < high; j++) {
        if(arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }

    swap(arr[i + 1], arr[high]); // letakkan pivot di posisi yang benar
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if(low < high) {
        int pi = partition(arr, low, high); // posisi pivot

        quickSort(arr, low, pi - 1);  // quick sort kiri
        quickSort(arr, pi + 1, high); // quick sort kanan
    }
}

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for(int& x : arr) cin >> x;

    quickSort(arr, 0, n - 1);

    for(int x : arr) cout << x << " ";
    cout << "\n";

    return 0;
}
```

Time complexity: $O(n \; log \;n)$
Memory complexity: $O(1)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 

## ğŸ§  Editorial: Implementasi Quick Sort

### ğŸ“‹ Deskripsi Masalah

Program ini mengimplementasikan algoritma **Quick Sort** untuk mengurutkan array dari input. Quick Sort adalah algoritma _divide and conquer_ yang bekerja dengan memilih satu elemen sebagai _pivot_, kemudian mempartisi elemen-elemen lainnya ke kiri (_lebih kecil_) dan kanan (_lebih besar_) dari pivot, lalu melakukan pengurutan secara rekursif pada dua bagian tersebut.

---

### ğŸ§© Penjelasan Kode

#### ğŸ”¹ Fungsi `partition()`

Fungsi ini menerima array dan dua indeks `low` dan `high`. Tujuannya adalah untuk meletakkan elemen _pivot_ (diambil dari `arr[high]`) pada posisi yang benar di array, sehingga semua elemen di sebelah kiri pivot < pivot dan semua elemen di sebelah kanan > pivot.

```cpp
int pivot = arr[high]; // pilih pivot
int i = low - 1;
```

Kita iterasi dari `low` hingga `high - 1`. Jika `arr[j] < pivot`, maka kita _increment_ `i` dan melakukan `swap(arr[i], arr[j])`.

Setelah loop selesai, kita meletakkan `pivot` pada posisi `i + 1`.

```cpp
swap(arr[i + 1], arr[high]);
return i + 1;
```

Fungsi ini mengembalikan posisi final dari _pivot_, yang akan digunakan untuk pemanggilan Quick Sort selanjutnya.

---

#### ğŸ”¹ Fungsi `quickSort()`

Fungsi ini adalah implementasi utama dari Quick Sort.

```cpp
if(low < high) {
    int pi = partition(arr, low, high);
    quickSort(arr, low, pi - 1);  // bagian kiri
    quickSort(arr, pi + 1, high); // bagian kanan
}
```

Selama `low < high`, kita partisi array dan melakukan rekursi ke dua bagian array yang terbentuk dari hasil partisi tersebut.

---

#### ğŸ”¹ Fungsi `main()`

Program utama hanya membaca input dari pengguna, memanggil `quickSort()` untuk mengurutkan array, dan mencetak hasilnya.

```cpp
int n;
cin >> n;
vector<int> arr(n);
for(int& x : arr) cin >> x;
quickSort(arr, 0, n - 1);
for(int x : arr) cout << x << " ";
```

---

### âš™ï¸ Contoh Input & Output

**Input:**

```
5
4 2 5 1 3
```

**Output:**

```
1 2 3 4 5
```

---

### â±ï¸ Kompleksitas Waktu

- **Best case:** O(n log n)
    
- **Average case:** O(n log n)
    
- **Worst case:** O(nÂ²) â†’ terjadi jika pivot selalu elemen terkecil atau terbesar (contoh array sudah terurut)
    

---

### âœ… Kelebihan Quick Sort

- Efisien untuk array besar
    
- Tidak membutuhkan memori tambahan besar seperti Merge Sort
    

---

### âš ï¸ Catatan

- Quick Sort tidak _stable_ (tidak mempertahankan urutan elemen yang sama).
    
- Untuk menghindari kasus terburuk, pemilihan pivot bisa dioptimasi (contoh: pilih median, atau random pivot).
    

# Informasi tambahan