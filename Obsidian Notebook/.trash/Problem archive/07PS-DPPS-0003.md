---
obsidianUIMode: preview
note_type: problem set
id_problem: 07PS-DPPS-0003
judul_problem: Segitiga pascal II
sumber: leetcode.com
kategori_problem: üìä problem_statement
kesulitan: ü•â easy
time_complexity: ‚ö™O(rowIndex¬≤)
memory_complexity: ‚ö™O(rowIndex)
status: üèÜ solved
date_solved: 2025-04-16T11:40:00
pendekatan: dynamic programming
tags:
  - array
  - dynamic-programming
---
Link problem: [Pascal's Triangle II - LeetCode](https://leetcode.com/problems/pascals-triangle-ii/description/?envType=problem-list-v2&envId=dynamic-programming)

#array  #dynamic-programming 

---
# Segitiga pascal II
Time limit: -
Memory limit: -

Diberikan sebuah bilangan bulat `rowIndex`, kembalikan baris ke-`rowIndex` (berbasis 0) dari segitiga Pascal.

Dalam segitiga Pascal, setiap angka merupakan jumlah dari dua angka yang berada tepat di atasnya seperti yang ditunjukkan:

![[PascalTriangleAnimated2.gif]]

---

**Contoh 1:**

Input: `rowIndex = 3`  
Output: `[1, 3, 3, 1]`

**Contoh 2:**

Input: `rowIndex = 0`  
Output: `[1]`

**Contoh 3:**

Input: `rowIndex = 1`  
Output: `[1, 1]`

---

**Constraints:**

```
0 <= rowIndex <= 33
```

---

**Follow up:** Dapatkah kamu mengoptimalkan algoritma agar hanya menggunakan ruang tambahan sebesar `O(rowIndex)`?

# Jawaban
Jawaban ini sudah cukup efektif, berjalan dalam 0 ms runtime, dan menggunakan memory yang lebih sedikit: 

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row(rowIndex + 1, 0);
        row[0] = 1;

        for (int i = 1; i <= rowIndex; ++i) {
            for (int j = i; j >= 1; --j) {
                row[j] += row[j - 1];
            }
        }
        return row;
    }
};
```

Time complexity: $O(rowIndex^2)$
Memory complexity: $O(rowIndex)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 


```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row(rowIndex + 1, 0);
        row[0] = 1;

        for (int i = 1; i <= rowIndex; ++i) {
            for (int j = i; j >= 1; --j) {
                row[j] += row[j - 1];
            }
        }
        return row;
    }
};
```

---

### üí° Penjelasan Inti:

- Kita hanya menyimpan **1 baris** (bukan seluruh segitiga) dalam array `row`.
    
- Baris ini kita **update secara in-place dari belakang ke depan**, agar nilai `row[j - 1]` belum tertimpa saat dipakai.
    
- Ini menghemat ruang, jadi kita bisa pakai **`O(n)` space**, bukan `O(n¬≤)`.
    

---

### üîÑ Contoh Proses (jika `rowIndex = 3`):

```
Iterasi i = 1 ‚Üí row = [1, 1, 0, 0]
Iterasi i = 2 ‚Üí row = [1, 2, 1, 0]
Iterasi i = 3 ‚Üí row = [1, 3, 3, 1]
```

# Informasi tambahan
Kita bedah per baris kode dan analisis kompleksitasnya!


```cpp
vector<int> getRow(int rowIndex) {
    // 1. Membuat vektor berukuran rowIndex+1, diisi dengan 0.
    vector<int> row(rowIndex + 1, 0);
    row[0] = 1;  // 2. Baris pertama selalu dimulai dengan angka 1.
    
    for (int i = 1; i <= rowIndex; ++i) {  // 3. Loop untuk setiap baris (1 hingga rowIndex).
        for (int j = i; j >= 1; --j) {   // 4. Loop untuk meng-update baris dari belakang.
            row[j] += row[j - 1];  // 5. Nilai row[j] diperbarui dengan jumlah row[j] dan row[j-1].
        }
    }
    return row;  // 6. Mengembalikan hasil baris yang diminta.
}
```

### Rincian Setiap Baris:

1. **`vector<int> row(rowIndex + 1, 0);`**
    
    - Membuat sebuah vektor `row` dengan ukuran `rowIndex + 1`, yang terisi dengan angka 0.
        
    - Ini akan menampung angka-angka dalam baris Pascal yang ke-`rowIndex`.
        
2. **`row[0] = 1;`**
    
    - Baris Pascal selalu dimulai dengan angka 1, jadi kita tetapkan elemen pertama dari `row` menjadi 1.
        
3. **`for (int i = 1; i <= rowIndex; ++i)`**
    
    - Loop untuk iterasi dari `1` hingga `rowIndex`, karena kita mulai dari baris kedua hingga baris yang diminta.
        
4. **`for (int j = i; j >= 1; --j)`**
    
    - Untuk setiap baris, kita mulai meng-update elemen dari belakang ke depan untuk menghindari penimpaan nilai pada baris yang sedang dihitung.
        
    - Misalnya pada baris ke-3, kita akan mulai dari posisi ke-3 dan bergerak ke kiri agar kita tidak menimpa nilai yang sebelumnya digunakan untuk perhitungan.
        
5. **`row[j] += row[j - 1];`**
    
    - Baris Pascal dihitung dengan menjumlahkan dua angka di atasnya. Jadi, kita update nilai `row[j]` dengan menjumlahkan `row[j]` (sekarang) dan `row[j - 1]` (di atasnya pada baris sebelumnya).
        
6. **`return row;`**
    
    - Setelah loop selesai, kita kembalikan hasilnya, yaitu baris ke-`rowIndex` yang telah dihitung.
        

---

### Kompleksitas Big O:

#### Time Complexity:

- Ada dua loop:
    
    - **Loop pertama**: berjalan dari `1` hingga `rowIndex` ‚Üí `O(rowIndex)`.
        
    - **Loop kedua**: untuk setiap iterasi di atas, loop ini berjalan dari `i` hingga `1` ‚Üí `O(i)`.
        

Karena setiap iterasi kedua adalah `O(i)`, maka total waktu adalah jumlah dari `1 + 2 + 3 + ... + rowIndex`, yang menghasilkan:

```
O(rowIndex * (rowIndex + 1) / 2) = O(rowIndex^2)
```

#### **Space Complexity:**

- Kita hanya menggunakan **`O(rowIndex)`** ruang untuk menyimpan satu baris segitiga Pascal, yaitu array `row` yang ukurannya `rowIndex + 1`.
    

Jadi, **space complexity** adalah:

```
O(rowIndex)
```
