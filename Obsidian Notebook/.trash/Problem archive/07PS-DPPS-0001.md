---
obsidianUIMode: preview
note_type: problem set
id_problem: 07PS-DPPS-0001
judul_problem: staircase climbing
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ  O(n)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-16T11:13:00
pendekatan: dynamic programming
tags:
  - math
  - dynamic-programming
  - memoization
---
Link problem: [Climbing Stairs - LeetCode](https://leetcode.com/problems/climbing-stairs/description/?envType=problem-list-v2&envId=dynamic-programming)

#math #dynamic-programming #memoization

---
# Tangga Naik (Staircase Climbing)
Time limit: -
Memory limit: -

Kamu sedang menaiki sebuah tangga. Diperlukan **n langkah** untuk mencapai puncaknya.

Setiap kali melangkah, kamu bisa memilih untuk naik **1 langkah** atau **2 langkah**.  
Dalam berapa **banyak cara berbeda** kamu bisa mencapai puncak tangga?

---

### ğŸ“¥ Contoh 1:

**Input:** `n = 2`  
**Output:** `2`  
**Penjelasan:** Ada dua cara untuk mencapai puncak:

1. 1 langkah + 1 langkah
    
2. 2 langkah
    

---

### ğŸ“¥ Contoh 2:

**Input:** `n = 3`  
**Output:** `3`  
**Penjelasan:** Ada tiga cara untuk mencapai puncak:

1. 1 + 1 + 1
    
2. 1 + 2
    
3. 2 + 1
    

---

### ğŸ”’ Batasan:

- `1 <= n <= 45`

# Jawaban
Jawaban ini sudah cukup efektif, karena dapat berjalan dalam runtime 0 ms:

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n ==1 ) return 1;
        int prev1 = 1;
        int prev2 = 1;
        int curr;

        for(int i=2; i <= n; ++i){
            curr=prev1+prev2;
            prev2=prev1;
            prev1=curr;
        }

        return prev1;
    }
};
```

Time complexity: $O(n)$
Memory complexity: $O(1)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 

### âœ… C++ Code (Tabulation / Bottom-Up DP)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int climbStairs(int n) {
    if (n == 1) return 1;
    vector<int> dp(n + 1);
    dp[0] = 1;  // 1 cara untuk tetap di bawah
    dp[1] = 1;  // 1 cara untuk mencapai anak tangga ke-1

    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

int main() {
    int n;
    cin >> n;
    cout << climbStairs(n) << endl;
    return 0;
}
```

---

### ğŸ’¡ Penjelasan:
- **State:** `dp[i]` = jumlah cara untuk mencapai anak tangga ke-`i`
- **Base case:**
  - `dp[0] = 1` â†’ 1 cara untuk tidak naik sama sekali
  - `dp[1] = 1` â†’ hanya ada 1 cara untuk mencapai tangga pertama
- **Transisi:**  
  Untuk mencapai `dp[i]`, kamu bisa datang dari:
  - `dp[i-1]` (1 langkah sebelumnya)
  - `dp[i-2]` (2 langkah sebelumnya)  
  Maka: `dp[i] = dp[i-1] + dp[i-2]`

---
## Versi dioptimasi memory
Nah, ini dia versi **optimal O(1) space complexity** dari solusi tangga naik!  

Kita cuma butuh dua variabel karena kita selalu hanya melihat dua langkah sebelumnyaâ€”jadi gak perlu array besar.

---

### âœ… C++ Code (Optimasi Ruang)

```cpp
#include <iostream>
using namespace std;

int climbStairs(int n) {
    if (n == 1) return 1;
    int prev1 = 1; // dp[i-1]
    int prev2 = 1; // dp[i-2]
    int curr;

    for (int i = 2; i <= n; ++i) {
        curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }

    return prev1;
}

int main() {
    int n;
    cin >> n;
    cout << climbStairs(n) << endl;
    return 0;
}
```

---

### ğŸ” Kenapa efisien?

- Hanya pakai **3 variabel** (`curr`, `prev1`, `prev2`)
    
- Kompleksitas waktu tetap **O(n)**
    
- Tapi kompleksitas ruang jadi **O(1)**
    

# Informasi tambahan