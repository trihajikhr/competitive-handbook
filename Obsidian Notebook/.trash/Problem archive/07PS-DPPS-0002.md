---
obsidianUIMode: preview
note_type: problem set
id_problem: 07PS-DPPS-0002
judul_problem: Segitiga pascal
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ£ O(nÂ²)
memory_complexity: ğŸŸ£ O(nÂ²)
status: ğŸ† solved
date_solved: 2025-04-16T11:22:00
pendekatan: dynamic programming
tags:
  - array
  - dynamic-programming
---
Link problem: [Pascal's Triangle - LeetCode](https://leetcode.com/problems/pascals-triangle/description/?envType=problem-list-v2&envId=dynamic-programming)

#array  #dynamic-programming 

---
# Segitiga pascal
Time limit: -
Memory limit: -


Diberikan sebuah bilangan bulat `numRows`, kembalikan **`numRows` baris pertama dari segitiga Pascal**.

Dalam **segitiga Pascal**, setiap angka adalah hasil penjumlahan dari **dua angka di atasnya secara langsung**, seperti yang ditunjukkan di bawah ini:

![[PascalTriangleAnimated2.gif]]

---

### ğŸ“¥ Contoh 1:

**Input:** `numRows = 5`  
**Output:**

```
[
 [1],
 [1,1],
 [1,2,1],
 [1,3,3,1],
 [1,4,6,4,1]
]
```

---

### ğŸ“¥ Contoh 2:

**Input:** `numRows = 1`  
**Output:**

```
[
 [1]
]
```

---

### ğŸ”’ Batasan:

- `1 <= numRows <= 30`
    

---

Kalau sudah siap, aku lanjut ke **solusi C++** dengan pendekatan _constructive DP_. 

# Jawaban
Jawaban yang sudah cukup cepat, berjalan dalam runtime 0 ms:

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> triangle(numRows);

        for(int i=0; i <numRows; ++i){
            triangle[i].resize(i+1);
            triangle[i][0] = triangle[i][i]=1;

            for(int j=1; j<i; ++j){
                triangle[i][j]=triangle[i-1][j-1]+triangle[i-1][j];
            }
        }
        return triangle;
    }
};
```

Time complexity: $O(n^2)$
Memory complexity: $O(n^2)$
## Jawaban efektif
Jawaban veri lain, dengan penggunaan memory yang lebih kecil:

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> result;

        for (int i = 1; i < numRows + 1; i++) {
            vector<int> lst(i, 1);
            if (i > 2) {
                for (int j = 1; j < i - 1; j++) {
                    lst[j] = result[result.size()-1][j-1] + result[result.size()-1][j];
                }
            }
            result.push_back(lst);
        }
        return result;
    }
};
```

Time complexity: $O(n^2)$
Memory complexity: $O(n^2)$
# Editorial 

### âœ… C++ Code â€“ Pascalâ€™s Triangle

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<vector<int>> generate(int numRows) {
    vector<vector<int>> triangle(numRows);

    for (int i = 0; i < numRows; ++i) {
        triangle[i].resize(i + 1); // Set ukuran baris ke-i
        triangle[i][0] = triangle[i][i] = 1; // Elemen pertama dan terakhir selalu 1

        for (int j = 1; j < i; ++j) {
            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; // Jumlahkan dua di atasnya
        }
    }

    return triangle;
}

int main() {
    int numRows;
    cin >> numRows;

    vector<vector<int>> pascal = generate(numRows);

    for (const auto& row : pascal) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}
```

---

### ğŸ’¡ Penjelasan:

- Kita buat `triangle` sebanyak `numRows`.
    
- Untuk setiap baris:
    
    - Panjang baris ke-`i` adalah `i + 1`.
        
    - Elemen pertama dan terakhir di-set ke `1`.
        
    - Sisanya dihitung dari dua angka di atas (kiri dan kanan).

## Penjelasan dan pembedahan detail

```cpp
#include <iostream>
#include <vector>
using namespace std;
```

ğŸ“Œ **Penjelasan:**

- `#include <iostream>` â†’ untuk input/output di terminal.
    
- `#include <vector>` â†’ kita pakai `vector` 2D untuk menyimpan segitiga Pascal.
    
- `using namespace std;` â†’ supaya tidak perlu menulis `std::vector`, `std::cout`, dll.
    

---

### Fungsi `generate()`

```cpp
vector<vector<int>> generate(int numRows)
```

ğŸ“Œ **Fungsi** untuk mengembalikan `numRows` baris pertama segitiga Pascal. Mengembalikan 2D vector (`vector<vector<int>>`).

---

```cpp
vector<vector<int>> triangle(numRows);
```

ğŸ“Œ Kita inisialisasi `triangle` sebagai **vector of vectors**, yang akan menyimpan setiap baris dari Pascal's Triangle.

---

### Loop utama membangun triangle

```cpp
for (int i = 0; i < numRows; ++i) {
```

ğŸ“Œ Untuk setiap baris dari 0 sampai `numRows - 1`, kita buat baris baru pada segitiga.

---

```cpp
    triangle[i].resize(i + 1);
```

ğŸ“Œ Setiap baris ke-`i` akan memiliki panjang `i + 1`.  
Contoh:

- baris 0 â†’ 1 elemen
    
- baris 1 â†’ 2 elemen
    
- dst...
    

---

```cpp
    triangle[i][0] = triangle[i][i] = 1;
```

ğŸ“Œ Angka pertama dan terakhir pada setiap baris segitiga Pascal **selalu bernilai 1**.

---

### Isi bagian tengah segitiga

```cpp
    for (int j = 1; j < i; ++j) {
        triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
    }
```

ğŸ“Œ Untuk indeks `j` dari 1 sampai `i - 1`, kita isi dengan **penjumlahan dua elemen atasnya**:

- `triangle[i - 1][j - 1]` â†’ elemen kiri atas
    
- `triangle[i - 1][j]` â†’ elemen kanan atas
    

ğŸ”¢ Contoh pada baris ke-3:

```
       1
      1 1
    1  2  1
   1 3  3  1  â† baris ini dibentuk dari baris sebelumnya
```

---

### Fungsi utama (main)

```cpp
int main() {
    int numRows;
    cin >> numRows;
```

ğŸ“Œ Menerima input dari user: berapa baris yang ingin dibentuk.

---

```cpp
    vector<vector<int>> pascal = generate(numRows);
```

ğŸ“Œ Panggil fungsi `generate()` untuk membangun segitiga dan simpan hasilnya.

---

### Output hasilnya

```cpp
    for (const auto& row : pascal) {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }
```

ğŸ“Œ Dua loop bersarang untuk mencetak setiap baris:

- Loop luar â†’ per baris
    
- Loop dalam â†’ per angka dalam baris  
    Tiap angka dipisahkan dengan spasi dan dicetak ke terminal.
    

---

## ğŸ”š Ringkasan Alur:

1. Siapkan array `triangle` kosong.
    
2. Bangun baris demi baris:
    
    - Ujung-ujung di-set 1.
        
    - Tengahnya = jumlah dua angka di atasnya.
        
3. Cetak semua baris hasilnya.
    


# Informasi tambahan