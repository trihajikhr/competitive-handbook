---
obsidianUIMode: preview
note_type: problem set
id_problem: 07PS-DPPS-0004
judul_problem: Waktu terbaik untuk membeli dan mejual Stock
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ  O(n)
memory_complexity: ğŸŸ¢ O(1)
status: ğŸ† solved
date_solved: 2025-04-16T12:44:00
pendekatan: dynamic programming
tags:
  - array
  - dynamic-programming
---
Link problem: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/?envType=problem-list-v2&envId=dynamic-programming

#array #dynamic-programming 

---
# Waktu terbaik untuk membeli dan mejual Stock
Time limit: -
Memory limit: -


Diberikan sebuah array `prices` di mana `prices[i]` adalah harga suatu saham pada hari ke-`i`.

Kamu ingin memaksimalkan keuntunganmu dengan memilih **satu hari** untuk membeli **satu saham**, dan memilih **hari yang berbeda di masa depan** untuk menjual saham tersebut.

Kembalikan **keuntungan maksimum** yang bisa kamu capai dari transaksi ini. Jika kamu **tidak dapat** memperoleh keuntungan apa pun, kembalikan `0`.

---

### Contoh 1:

**Input:** `prices = [7,1,5,3,6,4]`  
**Output:** `5`  
**Penjelasan:**  
Beli pada hari ke-2 (harga = 1) dan jual pada hari ke-5 (harga = 6), keuntungan = 6 - 1 = 5.  
Perhatikan bahwa membeli pada hari ke-2 dan menjual pada hari ke-1 **tidak diperbolehkan** karena kamu harus membeli **sebelum** menjual.

---

### Contoh 2:

**Input:** `prices = [7,6,4,3,1]`  
**Output:** `0`  
**Penjelasan:**  
Dalam kasus ini, **tidak ada transaksi** yang dilakukan dan keuntungan maksimum = 0.

---

### Batasan:

- `1 <= prices.length <= 10âµ`
    
- `0 <= prices[i] <= 10â´`
    
# Jawaban
Program ini cukup cepat, berjalan dalam 0 ms runtime:

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int maxProfit=0;

        for(int i=0; i<prices.size(); ++i){
            minPrice=min(minPrice, prices[i]);

            maxProfit=max(maxProfit,prices[i]-minPrice);
        }

        return maxProfit;
    }
};
```

Time complexity: $O(n)$
Memory complexity: $O(1)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 

Berikut adalah solusi untuk masalah **"Best Time to Buy and Sell Stock"** menggunakan pendekatan yang efisien:

### Solusi C++

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;  // 1. Menyimpan harga terendah yang ditemukan sejauh ini.
        int maxProfit = 0;       // 2. Menyimpan keuntungan maksimum yang bisa didapat.

        for (int i = 0; i < prices.size(); ++i) {  // 3. Loop untuk mengecek harga saham pada setiap hari.
            // Update harga terendah
            minPrice = min(minPrice, prices[i]);

            // Update keuntungan maksimum jika harga saham saat ini lebih tinggi dari harga terendah sebelumnya
            maxProfit = max(maxProfit, prices[i] - minPrice);
        }

        return maxProfit;  // 4. Mengembalikan keuntungan maksimum yang bisa didapat.
    }
};
```

### Penjelasan Kode:

1. **`int minPrice = INT_MAX;`**
    
    - Inisialisasi harga saham terendah dengan nilai terbesar yang mungkin, yaitu `INT_MAX`, untuk memastikan harga pertama yang kita lihat akan menjadi harga terendah.
        
2. **`int maxProfit = 0;`**
    
    - Inisialisasi keuntungan maksimum dengan `0` (artinya, jika tidak ada keuntungan yang dapat diperoleh, kita akan mengembalikan 0).
        
3. **`for (int i = 0; i < prices.size(); ++i)`**
    
    - Iterasi melalui seluruh harga saham yang tersedia.
        
4. **`minPrice = min(minPrice, prices[i]);`**
    
    - Pada setiap hari, kita memperbarui harga terendah yang telah ditemukan dengan membandingkan harga hari ini dengan harga terendah yang sudah ada.
        
5. **`maxProfit = max(maxProfit, prices[i] - minPrice);`**
    
    - Pada setiap hari, kita menghitung potensi keuntungan dengan menjual saham pada harga hari ini dan membeli pada harga terendah yang sudah ditemukan sebelumnya. Kita terus memperbarui keuntungan maksimum.
        
6. **`return maxProfit;`**
    
    - Setelah selesai mengecek semua harga, kita mengembalikan keuntungan maksimum yang ditemukan.
        

---

### Kompleksitas:

#### Time Complexity:

- **O(n)**, di mana `n` adalah panjang array `prices`. Kita hanya melakukan satu kali iterasi untuk mengecek harga saham pada setiap hari.
    

#### Space Complexity:

- **O(1)**, karena kita hanya menggunakan variabel tambahan (`minPrice` dan `maxProfit`) yang tidak bergantung pada ukuran input.
    
# Informasi tambahan