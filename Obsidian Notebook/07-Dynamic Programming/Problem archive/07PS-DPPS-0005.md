---
obsidianUIMode: preview
note_type: problem set
id_problem: 07PS-DPPS-0005
judul_problem: Counting Bits
sumber: leetcode.com
kategori_problem: ğŸ“Š problem_statement
kesulitan: ğŸ¥‰ easy
time_complexity: ğŸŸ  O(n)
memory_complexity: ğŸŸ  O(n)
status: ğŸ† solved
date_solved: 2025-04-16T13:16:00
pendekatan: dynamic programming
tags:
  - dynamic-programming
  - bit-manipulation
---
Link problem: https://leetcode.com/problems/counting-bits/description/?envType=problem-list-v2&envId=dynamic-programming

#dynamic-programming #bit-manipulation 

---
# Counting Bits
Time limit: -
Memory limit: -

Diberikan sebuah integer `n`, kembalikan sebuah array `ans` dengan panjang `n + 1` sehingga untuk setiap `i` (0 <= i <= n), `ans[i]` adalah jumlah angka 1 dalam representasi biner dari `i`.

---

### Contoh 1:

**Input:** `n = 2`  
**Output:** `[0,1,1]`  
**Penjelasan:**  
0 --> 0  
1 --> 1  
2 --> 10

---

### Contoh 2:

**Input:** `n = 5`  
**Output:** `[0,1,1,2,1,2]`  
**Penjelasan:**  
0 --> 0  
1 --> 1  
2 --> 10  
3 --> 11  
4 --> 100  
5 --> 101

---

### Batasan:

- `0 <= n <= 10âµ`
    

---

### Follow-up:

- Sangat mudah untuk membuat solusi dengan runtime O(n log n). Bisakah kamu melakukannya dalam waktu linear O(n) dan mungkin dalam satu kali lintasan?
    
- Bisakah kamu melakukannya tanpa menggunakan fungsi bawaan apapun (seperti `__builtin_popcount` di C++)?
    
# Jawaban
Jawaban yang cukup cepat, berjalan dengan 0 ms runtime:

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n+1, 0);

        for(int i=1; i<=n; ++i){
            ans[i] = ans[i >> 1] + (i&1);
        }
        return ans;
    }
};
```

Time complexity: $O(n)$
Memory complexity: $O(n)$
## Jawaban efektif
// penjelasan singkat

```cpp

```

Time complexity: $O()$
Memory complexity: $O()$
# Editorial 
Berikut adalah solusi untuk masalah **"Count of Bits"** yang mencari jumlah angka 1 dalam representasi biner dari setiap angka dari 0 hingga n:

### Solusi C++

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n + 1, 0);  // 1. Inisialisasi vector untuk menyimpan jumlah 1 dalam setiap bilangan biner.

        for (int i = 1; i <= n; ++i) {  // 2. Iterasi dari 1 hingga n.
            ans[i] = ans[i >> 1] + (i & 1);  // 3. Gunakan teknik bitwise untuk menghitung jumlah 1.
        }

        return ans;  // 4. Kembalikan vector hasilnya.
    }
};
```

### Penjelasan Kode:

1. **`vector<int> ans(n + 1, 0);`**
    
    - Membuat vector `ans` dengan panjang `n + 1` yang semuanya diinisialisasi dengan 0. Vector ini akan menyimpan hasil jumlah angka 1 untuk setiap angka dari 0 hingga n.
        
2. **`for (int i = 1; i <= n; ++i)`**
    
    - Iterasi dari 1 hingga `n`. Kita mulai dari 1 karena jumlah 1 untuk `0` sudah terinisialisasi dengan benar sebelumnya.
        
3. **`ans[i] = ans[i >> 1] + (i & 1);`**
    
    - Ini adalah inti dari solusi, menggunakan teknik bitwise:
        
        - `i >> 1`: Menggeser bit `i` ke kanan satu posisi. Ini memberikan angka yang lebih kecil dari `i` dan bisa digunakan untuk mengakses hasil yang sudah dihitung sebelumnya. Secara efektif, kita memanfaatkan hasil perhitungan sebelumnya.
            
        - `(i & 1)`: Mengecek apakah bit paling kanan dari `i` adalah 1 atau tidak. Jika 1, maka hasilnya 1, jika 0, hasilnya 0. Ini digunakan untuk menambah 1 jika bit paling kanan adalah 1.
            
4. **`return ans;`**
    
    - Mengembalikan vector `ans` yang berisi jumlah angka 1 dalam representasi biner setiap angka dari 0 hingga `n`.
        

---

### Kompleksitas:

#### Time Complexity:

- **O(n)**, karena kita hanya melakukan satu iterasi melalui angka dari 1 hingga `n`, dan setiap operasi di dalam loop adalah operasi konstanta (bitwise).
    

#### Space Complexity:

- **O(n)**, karena kita menyimpan hasil dalam vector `ans` yang berukuran `n + 1`.
    

---

Dengan teknik bitwise ini, kita berhasil mengoptimalkan perhitungan jumlah bit menjadi **O(n)** dan menghindari penggunaan fungsi bawaan. 
# Informasi tambahan